<html>
<body></br>
</br>
</br>
	<a></a>
	</br> 
	</br>
	
	<h1><span>Monad (functional programming)</span></h1>
	</br>
		</br>From Wikipedia, the free encyclopedia
		</br>
		</br>
		
		</br>
		<a>Jump to navigation</a>
		<a>Jump to search</a>
		</br></br></br>Design pattern in functional programming to build generic types
<style>.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style></br>For the concept in category theory, see <a>Monad (category theory)</a>.
<p>In <a>functional programming</a>, a <b>monad</b> is a <a>software design pattern</a> with a structure that combines program fragments (<a>functions</a>) and wraps their <a>return values</a> in a <a>type</a> with additional computation. In addition to defining a wrapping <b>monadic type</b>, monads define two <a>operators</a>: one to wrap a value in the monad type, and another to compose together functions that output values of the monad type (these are known as <b>monadic functions</b>). General-purpose languages use monads to reduce <a>boilerplate code</a> needed for common operations (such as dealing with undefined values or fallible functions, or encapsulating bookkeeping code). Functional languages use monads to turn complicated sequences of functions into succinct pipelines that abstract away <a>control flow</a>, and <a>side-effects</a>.<div><a>[1]</a></div><div><a>[2]</a></div>
</p><p>Both the concept of a monad and the term originally come from <a>category theory</a>, where a monad is defined as a <a>functor</a> with additional structure.<div><a>[a]</a></div> Research beginning in the late 1980s and early 1990s established that monads could bring seemingly disparate computer-science problems under a unified, functional model. Category theory also provides a few formal requirements, known as the <b><a>monad laws</a></b>, which should be satisfied by any monad and can be used to <a>verify</a> monadic code.<div><a>[3]</a></div><div><a>[4]</a></div>
</p><p>Since monads make <a>semantics</a> explicit for a kind of computation, they can also be used to implement convenient language features. Some languages, such as <a>Haskell</a>, even offer pre-built definitions in their core <a>libraries</a> for the general monad structure and common instances.<div><a>[1]</a></div><div><a>[5]</a></div>
</p>
</br><input></input></br><div>Contents</div><span><label></label></span>
<ul>
<li><a><span>1</span> <span>Overview</span></a>
<ul>
<li><a><span>1.1</span> <span>An example: Maybe</span></a></li>
<li><a><span>1.2</span> <span>Definition</span></a></li>
<li><a><span>1.3</span> <span>Usage</span></a></li>
</ul>
</li>
<li><a><span>2</span> <span>Applications</span></a></li>
<li><a><span>3</span> <span>History</span></a></li>
<li><a><span>4</span> <span>Analysis</span></a>
<ul>
<li><a><span>4.1</span> <span>Verifying the monad laws</span></a></li>
<li><a><span>4.2</span> <span>Derivation from functors</span></a></li>
<li><a><span>4.3</span> <span>Another example: List</span></a></li>
</ul>
</li>
<li><a><span>5</span> <span>Techniques</span></a>
<ul>
<li><a><span>5.1</span> <span>Syntactic sugar <span><span>do-notation</span></span></span></a></li>
<li><a><span>5.2</span> <span>General interface</span></a></li>
<li><a><span>5.3</span> <span>Operators</span></a></li>
</ul>
</li>
<li><a><span>6</span> <span>More examples</span></a>
<ul>
<li><a><span>6.1</span> <span>Identity monad</span></a></li>
<li><a><span>6.2</span> <span>Collections</span></a></li>
<li><a><span>6.3</span> <span>IO monad (Haskell)</span></a></li>
<li><a><span>6.4</span> <span>Writer monad (JavaScript)</span></a></li>
<li><a><span>6.5</span> <span>Environment monad</span></a></li>
<li><a><span>6.6</span> <span>State monads</span></a></li>
<li><a><span>6.7</span> <span>Continuation monad</span></a></li>
<li><a><span>6.8</span> <span>Program logging</span></a></li>
</ul>
</li>
<li><a><span>7</span> <span>Variations</span></a>
<ul>
<li><a><span>7.1</span> <span>Additive monads</span></a></li>
<li><a><span>7.2</span> <span>Free monads</span></a></li>
<li><a><span>7.3</span> <span>Comonads</span></a></li>
</ul>
</li>
<li><a><span>8</span> <span>See also</span></a></li>
<li><a><span>9</span> <span>Notes</span></a></li>
<li><a><span>10</span> <span>References</span></a></li>
<li><a><span>11</span> <span>External links</span></a></li>
</ul>


<div><span>Overview</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>"For a monad <code>m</code>, a value of type <code>m a</code> represents having access to a value of type <code>a</code> within the context of the monad." —C. A. McCann<div><a>[6]</a></div>
</p><p>More exactly, a monad can be used where unrestricted access to a value is inappropriate for reasons specific to the scenario. In the case of the Maybe monad, it is because the value may not exist. In the case of the IO monad, it is because the value may not be known yet, such as when the monad represents user input that will only be provided after a prompt is displayed. In all cases the scenarios in which access makes sense are captured by the bind operation defined for the monad; for the Maybe monad a value is bound only if it exists, and for the IO monad a value is bound only after the previous operations in the sequence have been performed.
</p><p>A monad can be created by defining a <a>type constructor</a> <i>M</i> and two operations:
</p>
<ul><li><code>return :: a -> M a</code> (often also called <i>unit</i>), which receives a value of type <code>a</code> and wraps it into a <i>monadic value</i> of type <code>m a</code>, and</li></ul>
<ul><li><code>bind :: (M a) -> (a -> M b) -> (M b)</code> (typically represented as <code>>>=</code>), which receives a function <code>f</code> over type <code>a</code> and can transform monadic values <code>m a</code> applying <code>f</code> to the unwrapped value <code>a</code>, returning a monadic value <code>M b</code>.</li></ul>
<p>(An alternative but <a>§ equivalent construct</a> using the <code>join</code>  function instead of the <code>bind</code> operator can be found in the later section <i><a>§ Derivation from functors</a></i>.)
</p><p><br></br>
With these elements, the programmer composes a sequence of function calls (a "pipeline") with several <i>bind</i> operators chained together in an expression. Each function call transforms its input plain-type value, and the bind operator handles the returned monadic value, which is fed into the next step in the sequence.
</p><p>Typically, the bind operator <code>>>=</code> may contain code unique to the monad that performs additional computation steps not available in the function received as a parameter. Between each pair of composed function calls, the bind operator can inject into the monadic value <code>m a</code> some additional information that is not accessible within the function <code>f</code>, and pass it along down the pipeline. It can also exert finer control of the flow of execution, for example by calling the function only under some conditions, or executing the function calls in a particular order.
</p>
<div><span>An example: Maybe</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<div></div></br>Further information: <a>Option type</a>
<p>One example of a monad is the <code>Maybe</code> type. Undefined null results are one particular pain point that many procedural languages don't provide specific tools for dealing with, requiring use of the <a>null object pattern</a> or checks to test for invalid values at each operation to handle undefined values. This causes bugs and makes it harder to build robust software that gracefully handles errors. The <code>Maybe</code> type forces the programmer to deal with these potentially undefined results by explicitly defining the two states of a result: <code>Just ⌑result⌑</code>, or <code>Nothing</code>. For example the programmer might be constructing a parser, which is to return an intermediate result, or else signal a condition which the parser has detected, and which programmer must also handle. With just a little extra functional spice on top, this <code>Maybe</code> type transforms into a fully-featured monad.<div><a>[b]</a></div><div><span>: 12.3 pages 148-151 </span></div>
</p><p>In most languages, the Maybe monad is also known as an <a>option type</a>, which is just a type that marks whether or not it contains a value. Typically they are expressed as some kind of <a>enumerated type</a>. In this Rust example we will call it <code>Maybe<T></code> and variants of this type can either be a value of <a>generic type</a> <code>T</code>, or the empty variant: <code>Nothing</code>.
</p>
</br><div><span></span><span>// The <T> represents a generic type "T"</span>
<span>enum</span> <span>Maybe</span><span><</span><span>T</span><span>></span><span> </span><span>{</span><span></span>
<span>    </span><span>Just</span><span>(</span><span>T</span><span>),</span><span></span>
<span>    </span><span>Nothing</span><span>,</span><span></span>
<span>}</span><span></span>
</div>
<p><code>Maybe<T></code> can also be understood as a "wrapping" type, and this is where its connection to monads comes in. In languages with some form of the <code>Maybe</code> type, there are functions that aid in their use such as composing <b>monadic functions</b> with each other and testing if a <code>Maybe</code> contains a value.
</p><p>
In the following hard-coded example, a <code>Maybe</code> type is used as a result of functions that may fail, in this case the type returns nothing if there is a <a>divide-by-zero</a>.</p></br><div><span></span><span>fn</span> <span>divide</span><span>(</span><span>x</span>: <span>Decimal</span><span>,</span><span> </span><span>y</span>: <span>Decimal</span><span>)</span><span> </span>-> <span>Maybe</span><span><</span><span>Decimal</span><span>></span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>y</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>Nothing</span><span> </span><span>}</span><span></span>
<span>    </span><span>else</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>Just</span><span>(</span><span>x</span><span> </span><span>/</span><span> </span><span>y</span><span>)</span><span> </span><span>}</span><span></span>
<span>}</span><span></span>
<span>// divide(1.0, 4.0) -> returns Just(0.25)</span>
<span>// divide(3.0, 0.0) -> returns Nothing</span>
</div><p>One such way to test whether or not a <code>Maybe</code> contains a value is to use <code>if</code> statements.</p></br><div><span></span><span>let</span><span> </span><span>m_x</span><span> </span><span>=</span><span> </span><span>divide</span><span>(</span><span>3.14</span><span>,</span><span> </span><span>0.0</span><span>);</span><span> </span><span>// see divide function above</span>
<span>// The if statement extracts x from m_x if m_x is the Just variant of Maybe</span>
<span>if</span><span> </span><span>let</span><span> </span><span>Just</span><span>(</span><span>x</span><span>)</span><span> </span><span>=</span><span> </span><span>m_x</span><span> </span><span>{</span><span></span>
<span>    </span><span>print</span><span>(</span><span>"answer: "</span><span>,</span><span> </span><span>x</span><span>)</span><span></span>
<span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>    </span><span>print</span><span>(</span><span>"division failed, divide by zero error..."</span><span>)</span><span></span>
<span>}</span><span></span>
</div><p>Other languages may have <a>pattern matching</a></p></br><div><span></span><span>let</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>divide</span><span>(</span><span>3.0</span><span>,</span><span> </span><span>2.0</span><span>);</span><span></span>
<span>match</span><span> </span><span>result</span><span> </span><span>{</span><span></span>
<span>    </span><span>Just</span><span>(</span><span>x</span><span>)</span><span> </span><span>=></span><span> </span><span>print</span><span>(</span><span>"answer: "</span><span>,</span><span> </span><span>x</span><span>),</span><span></span>
<span>    </span><span>Nothing</span><span> </span><span>=></span><span> </span><span>print</span><span>(</span><span>"division failed, we'll get em next time."</span><span>),</span><span></span>
<span>}</span><span></span>
</div><p>Monads can compose functions that return <code>Maybe</code> together. One concrete example to do this might be to have one function take in <code>Maybe</code>s and return a <code>Maybe</code> such as:
</p></br><div><span></span><span>fn</span> <span>chainable_division</span><span>(</span><span>maybe_x</span>: <span>Maybe</span><span><</span><span>Decimal</span><span>></span><span>,</span><span> </span><span>maybe_y</span>: <span>Maybe</span><span><</span><span>Decimal</span><span>></span><span>)</span><span> </span>-> <span>Maybe</span><span><</span><span>Decimal</span><span>></span><span> </span><span>{</span><span></span>
<span>    </span><span>match</span><span> </span><span>(</span><span>maybe_x</span><span>,</span><span> </span><span>maybe_y</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>(</span><span>Just</span><span>(</span><span>x</span><span>),</span><span> </span><span>Just</span><span>(</span><span>y</span><span>))</span><span> </span><span>=></span><span> </span><span>{</span><span> </span><span>// If both inputs are Just, check for division by zero and divide accordingly</span>
<span>            </span><span>if</span><span> </span><span>y</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>Nothing</span><span> </span><span>}</span><span></span>
<span>            </span><span>else</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>Just</span><span>(</span><span>x</span><span> </span><span>/</span><span> </span><span>y</span><span>)</span><span> </span><span>}</span><span></span>
<span>        </span><span>},</span><span></span>
<span>        </span><span>_</span><span> </span><span>=></span><span> </span><span>return</span><span> </span><span>Nothing</span><span> </span><span>// Otherwise return Nothing</span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>
<span>chainable_division</span><span>(</span><span>chainable_division</span><span>(</span><span>Just</span><span>(</span><span>2.0</span><span>),</span><span> </span><span>Just</span><span>(</span><span>0.0</span><span>)),</span><span> </span><span>Just</span><span>(</span><span>1.0</span><span>));</span><span> </span><span>// inside chainable_division fails, outside chainable_division returns Nothing</span>
</div><p>
Having to rewrite functions to take Maybes in this concrete example requires a lot of boilerplate (look at all those <code>Just</code> expressions!). Instead, we can use something called a <i>bind</i> operator. (also known as "map", "flatmap", or "shove"<div><a>[8]</a></div><div><span>: 2205s </span></div>). This operation takes a monad and a function that returns a monad and runs the function on the inner value of the passed monad, returning the monad from the function.</p></br><div><span></span><span>// Rust example using ".map". maybe_x is passed through 2 functions that return Maybe<Decimal> and Maybe<String> respectively.</span>
<span>// As with normal function composition the inputs and outputs of functions feeding into each other should match wrapped types. (i.e. the add_one function should return a Maybe<Decimal> which then can be unwrapped to a Decimal for the decimal_to_string function)</span>
<span>let</span><span> </span><span>maybe_x</span>: <span>Maybe</span><span><</span><span>Decimal</span><span>></span><span> </span><span>=</span><span> </span><span>Just</span><span>(</span><span>1.0</span><span>)</span><span></span>
<span>let</span><span> </span><span>maybe_result</span><span> </span><span>=</span><span> </span><span>maybe_x</span><span>.</span><span>map</span><span>(</span><span>|</span><span>x</span><span>|</span><span> </span><span>add_one</span><span>(</span><span>x</span><span>)).</span><span>map</span><span>(</span><span>|</span><span>x</span><span>|</span><span> </span><span>decimal_to_string</span><span>(</span><span>x</span><span>))</span><span></span>
</div><p>In Haskell, there is an operator <i>bind</i>, or (<code>>>=</code>) that allows for this monadic composition in a more elegant form similar to <a>function composition</a>.<div><a>[c]</a></div><div><span>: 150–151 </span></div>
</p></br><div><span></span><span>halve</span> <span>::</span> <span>Int</span> <span>-></span> <span>Maybe</span> <span>Int</span>
<span>halve</span> <span>x</span>
  <span>|</span> <span>even</span> <span>x</span> <span>=</span> <span>Just</span> <span>(</span><span>x</span> <span>`</span><span>div</span><span>`</span> <span>2</span><span>)</span>
  <span>|</span> <span>odd</span> <span>x</span>  <span>=</span> <span>Nothing</span>
 <span>-- This code halves x twice. it evaluates to Nothing if x is not a multiple of 4</span>
<span>halve</span> <span>x</span> <span>>>=</span> <span>halve</span>
</div>
<p>With <code>>>=</code> available, <code>chainable_division</code> can be expressed much more succinctly with the help of <a>anonymous functions</a> (i.e. lambdas). Notice in the expression below how the two nested lambdas each operate on the wrapped value in the passed <code>Maybe</code> monad using the bind operator.<div><a>[d]</a></div><div><span>: 93 </span></div>
</p>
</br><div><span></span> <span>chainable_division</span><span>(</span><span>mx</span><span>,</span><span>my</span><span>)</span> <span>=</span>   <span>mx</span> <span>>>=</span>  <span>(</span> <span>λx</span> <span>-></span>   <span>my</span> <span>>>=</span> <span>(</span><span>λy</span> <span>-></span> <span>Just</span> <span>(</span><span>x</span> <span>/</span> <span>y</span><span>))</span>   <span>)</span>
</div>
<p>What has been shown so far is basically a monad, but to be more concise, the following is a strict list of qualities necessary for a monad as defined by the following section.
</p>
<div><div><i>Monadic Type</i></div>
<div>A type (<code>Maybe</code>)<div><a>[b]</a></div><div><span>: 148–151 </span></div></div>
<div><i>Unit operation</i></div>
<div>A type converter (<code>Just(x)</code>)<div><a>[d]</a></div><div><span>: 93 </span></div></div>
<div><i>Bind operation</i></div>
<div>A combinator for monadic functions ( <code>>>=</code> or <code>.map()</code>)<div><a>[c]</a></div><div><span>: 150–151 </span></div></div></div>
<p>These are the 3 things necessary to form a monad. Other monads may embody different logical processes, and some may have additional properties, but all of them will have these three similar components.<div><a>[1]</a></div><div><a>[9]</a></div>
</p>
<div><span>Definition</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>The more common definition for a monad in functional programming, used in the above example, is actually based on a <a>Kleisli triple</a> ⟨T, η, μ⟩ rather than category theory's standard definition. The two constructs turn out to be mathematically equivalent, however, so either definition will yield a valid monad. Given any well-defined, basic types <span>T</span>, <span>U</span>, a monad consists of three parts:
</p>
<ul><li>A <a>type constructor</a> <span>M</span> that builds up a monadic type <span>M T</span><div><a>[e]</a></div></li>
<li>A <a>type converter</a>, often called <b>unit</b> or <b>return</b>, that embeds an object <span>x</span> in the monad:<style>.mw-parser-output .block-indent{padding-left:3em;padding-right:0;overflow:hidden}</style></br><code>unit : T → M T</code><div><a>[f]</a></div></li>
<li><span></span> A <a>combinator</a>, typically called <b>bind</b> (as in <a>binding a variable</a>) and represented with an <a>infix operator</a> <code>>>=</code> or a method called <b>flatMap</b>, that unwraps a monadic variable, then inserts it into a monadic function/expression, resulting in a new monadic value:<div></div></br><code>(>>=) : (M T, T → M U) → M U</code><div><a>[g]</a></div> so if <code>mx : M T</code> and <code>f : T → M U</code>, then <code> (mx >>= f) : M U</code></li></ul>
<p><span></span>
To fully qualify as a monad though, these three parts must also respect a few laws:
</p>
<ul><li><span>unit</span> is a <a>left-identity</a> for <span>bind</span>:<div></div></br><code>unit(x) >>= f</code> <b>↔</b> <code>f(x)</code></li>
<li><span>unit</span> is also a right-identity for <span>bind</span>:<div></div></br><code>ma >>= unit</code> <b>↔</b> <code>ma</code></li>
<li><span>bind</span> is essentially <a>associative</a>:<div><a>[h]</a></div><div></div></br><code>ma >>= λx → (f(x) >>= g)</code> <b>↔</b> <code>(ma >>= f) >>= g</code><div><a>[1]</a></div></li></ul>
<p>Algebraically, this means any monad both gives rise to a category (called the <a>Kleisli category</a>) <i>and</i> a <a>monoid</a> in the category of functors (from values to computations), with monadic composition as a binary operator in the monoid<div><a>[8]</a></div><div><span>: 2450s </span></div> and <span>unit</span> as identity in the monad.
</p>
<div><span>Usage</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>The value of the monad pattern goes beyond merely condensing code and providing a link to mathematical reasoning.
Whatever language or default <a>programming paradigm</a> a developer uses, following the monad pattern brings many of the benefits of <a>purely functional programming</a>.
By <a>reifying</a> a specific kind of computation, a monad not only <a>encapsulates</a> the tedious details of that computational pattern, but it does so in a <a>declarative</a> way, improving the code's clarity.
As monadic values explicitly represent not only computed values, but computed <i>effects</i>, a monadic expression can be replaced with its value in <a>referentially transparent positions</a>, much like pure expressions can be, allowing for many techniques and optimizations based on <a>rewriting</a>.<div><a>[4]</a></div>
</p><p>Typically, programmers will use <span>bind</span> to chain monadic functions into a sequence, which has led some to describe monads as "programmable semicolons", a reference to how many <a>imperative</a> languages use semicolons to separate <a>statements</a>.<div><a>[1]</a></div><div><a>[5]</a></div>
However, it should be stressed that monads do not actually order computations; even in languages that use them as central features, simpler function composition can arrange steps within a program.
A monad's general utility rather lies in simplifying a program's structure and improving <a>separation of concerns</a> through abstraction.<div><a>[4]</a></div><div><a>[11]</a></div>
</p><p>The monad structure can also be seen as a uniquely mathematical and <a>compile time</a> variation on the <a>decorator pattern</a>.
Some monads can pass along extra data that is inaccessible to functions, and some even exert finer control over execution, for example only calling a function under certain conditions.
Because they let application programmers implement <a>domain logic</a> while offloading boilerplate code onto pre-developed modules, monads can even be considered a tool for <a>aspect-oriented programming</a>.<div><a>[12]</a></div>
</p><p>One other noteworthy use for monads is isolating side-effects, like <a>input/output</a> or mutable <a>state</a>, in otherwise purely functional code.
Even purely functional languages <i>can</i> still implement these "impure" computations without monads, via an intricate mix of function composition and <a>continuation-passing style</a> (CPS) in particular.<div><a>[2]</a></div>
With monads though, much of this scaffolding can be abstracted away, essentially by taking each recurring pattern in CPS code and bundling it into a distinct monad.<div><a>[4]</a></div>
</p><p>If a language does not support monads by default, it is still possible to implement the pattern, often without much difficulty.
When translated from category-theory to programming terms, the monad structure is a <a>generic concept</a> and can be defined directly in any language that supports an equivalent feature for <a>bounded polymorphism</a>.
A concept's ability to remain agnostic about operational details while working on underlying types is powerful, but the unique features and stringent behavior of monads set them apart from other concepts.<div><a>[13]</a></div>
</p>
<div><span>Applications</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Discussions of specific monads will typically focus on solving a narrow implementation problem since a given monad represents a specific computational form.
In some situations though, an application can even meet its high-level goals by using appropriate monads within its core logic.
</p><p>Here are just a few applications that have monads at the heart of their designs:
</p>
<ul><li>The <a>Parsec</a> parser library uses monads to combine simpler <a>parsing</a> rules into more complex ones, and is particularly useful for smaller <a>domain-specific languages</a>.<div><a>[14]</a></div></li>
<li><a>xmonad</a> is a <a>tiling window manager</a> centered on the <a>zipper data structure</a>, which itself can be treated monadically as a specific case of <a>delimited continuations</a>.<div><a>[15]</a></div></li>
<li><a>LINQ</a> by <a>Microsoft</a> provides a <a>query language</a> for the <a>.NET Framework</a> that is heavily influenced by functional programming concepts, including core operators for composing queries monadically.<div><a>[16]</a></div></li>
<li><a>ZipperFS</a> is a simple, experimental <a>file system</a> that also uses the zipper structure primarily to implement its features.<div><a>[17]</a></div></li>
<li>The <a>Reactive extensions</a> framework essentially provides a (co)monadic interface to <a>data streams</a> that realizes the <a>observer pattern</a>.<div><a>[18]</a></div></li></ul>
<div><span>History</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>The term "monad" in programming actually goes all the way back to the <a>APL</a> and <a>J</a> programming languages, which do tend toward being purely functional. However, in those languages, "monad" is only shorthand for a function taking one parameter (a function with two parameters being a "dyad", and so on).<div><a>[19]</a></div>
</p><p>The mathematician <a>Roger Godement</a> was the first to formulate the concept of a monad (dubbing it a "standard construction") in the late 1950s, though the term "monad" that came to dominate was popularized by category-theorist <a>Saunders Mac Lane</a>.<div>[<i><a><span>citation needed</span></a></i>]</div> The form defined above using <span>bind</span>, however, was originally described in 1965 by mathematician <a>Heinrich Kleisli</a> in order to prove that any monad could be characterized as an <a>adjunction</a> between two (covariant) functors.<div><a>[20]</a></div>
</p><p>Starting in the 1980s, a vague notion of the monad pattern began to surface in the computer science community.
According to programming language researcher <a>Philip Wadler</a>, computer scientist <a>John C. Reynolds</a> anticipated several facets of it in the 1970s and early 1980s, when he discussed the value of <a>continuation-passing style</a>, category theory as a rich source for formal semantics, and the type distinction between values and computations.<div><a>[4]</a></div>
The research language <a>Opal</a>, which was actively designed up until 1990, also effectively based I/O on a monadic type, but the connection was not realized at the time.<div><a>[21]</a></div>
</p><p>The computer scientist <a>Eugenio Moggi</a> was the first to explicitly link the monad of category theory to functional programming, in a conference paper in 1989,<div><a>[22]</a></div> followed by a more refined journal submission in 1991. In earlier work, several computer scientists had advanced using category theory to provide semantics for the <a>lambda calculus</a>. Moggi's key insight was that a real-world program is not just a function from values to other values, but rather a transformation that forms <i>computations</i> on those values. When formalized in category-theoretic terms, this leads to the conclusion that monads are the structure to represent these computations.<div><a>[3]</a></div>
</p><p>Several others popularized and built on this idea, including Philip Wadler and <a>Simon Peyton Jones</a>, both of whom were involved in the specification of Haskell. In particular, Haskell used a problematic "lazy stream" model up through v1.2 to reconcile I/O with <a>lazy evaluation</a>, until switching over to a more flexible monadic interface.<div><a>[23]</a></div> The Haskell community would go on to apply monads to many problems in functional programming, and in the 2010s, researchers working with Haskell eventually recognized that monads are <a>applicative functors</a>;<div><a>[24]</a></div><div><a>[i]</a></div> and that both monads and <a>arrows</a> are <a>monoids</a>.<div><a>[26]</a></div>
</p><p>At first, programming with monads was largely confined to Haskell and its derivatives, but as functional programming has influenced other paradigms, many languages have incorporated a monad pattern (in spirit if not in name). Formulations now exist in <a>Scheme</a>, <a>Perl</a>, <a>Python</a>, <a>Racket</a>, <a>Clojure</a>, <a>Scala</a>, <a>F#</a>, and have also been considered for a new <a>ML</a> standard.<div>[<i><a><span>citation needed</span></a></i>]</div>
</p>
<div><span>Analysis</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>One benefit of the monad pattern is bringing mathematical precision on the composition of computations.
Not only can the monad laws be used to check an instance's validity, but features from related structures (like functors) can be used through <a>subtyping</a>.
</p>
<div><span>Verifying the monad laws</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Returning to the <code>Maybe</code> example, its components were declared to make up a monad, but no proof was given that it satisfies the monad laws.
</p><p>This can be rectified by plugging the specifics of <code>Maybe</code> into one side of the general laws, then algebraically building a chain of equalities to reach the other side:
</p>
<div><b>Law 1:</b>  eta(a) >>= f(x)  ⇔  (Just a) >>= f(x)  ⇔  f(a)
</div>
<div><b>Law 2:</b>  ma >>= eta(x)           ⇔  ma

        <b>if</b> ma <b>is</b> (Just a) <b>then</b>
            eta(a)              ⇔ Just a
        <b>else</b>                        <b>or</b>
            Nothing             ⇔ Nothing
        <b>end if</b>
</div>
<div><b>Law 3:</b>  <b>(</b>ma >>= f(x)<b>)</b> >>= g(y)                       ⇔  ma >>= <b>(</b>f(x) >>= g(y)<b>)</b>

        <b>if</b> (ma >>= f(x)) <b>is</b> (Just b) <b>then</b>               <b>if</b> ma <b>is</b> (Just a) <b>then</b>
            g(ma >>= f(x))                                (f(x) >>= g(y)) a
        <b>else</b>                                            <b>else</b>
            Nothing                                         Nothing
        <b>end if</b>                                          <b>end if</b>

                ⇔  <b>if</b> ma <b>is</b> (Just a) <b>and</b> f(a) <b>is</b> (Just b) <b>then</b>      
                       (g ∘ f) a
                   <b>else if</b> ma <b>is</b> (Just a) <b>and</b> f(a) <b>is Nothing then</b>
                       Nothing
                   <b>else</b>
                       Nothing
                   <b>end if</b>
</div>
<div><span>Derivation from functors <span></span><span></span></span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Though rarer in computer science, one can use category theory directly, which defines a monad as a <a>functor</a> with two additional <a>natural transformations</a>.<div><a>[j]</a></div>
So to begin, a structure requires a <a>higher-order function</a> (or "functional") named <b><a>map</a></b> to qualify as a functor:
</p>
<div></div></br><code>map φ : (a → b) → (ma → mb)</code>
<p>This is not always a major issue, however, especially when a monad is derived from a pre-existing functor, whereupon the monad inherits <span>map</span> automatically. (For historical reasons, this <code>map</code> is instead called <code>fmap</code> in Haskell.)
</p><p>A monad's first transformation is actually the same <span>unit</span> from the Kleisli triple, but following the hierarchy of structures closely, it turns out <span>unit</span> characterizes an <a>applicative functor</a>, an intermediate structure between a monad and a basic functor. In the applicative context, <span>unit</span> is sometimes referred to as <b>pure</b> but is still the same function. What does differ in this construction is the law <span>unit</span> must satisfy; as <span>bind</span> is not defined, the constraint is given in terms of <span>map</span> instead:
</p>
<div></div></br><code>(unit ∘ φ) x ↔ ((map φ) ∘ unit) x</code><div><a>[27]</a></div>
<p><span></span>
The final leap from applicative functor to monad comes with the second transformation, the <b>join</b> function (in category theory this is a natural transformation usually called <span>μ</span>), which "flattens" nested applications of the monad:
</p>
<div></div></br><code>join(mma) : M (M T) → M T</code>
<p>As the characteristic function, <span>join</span> must also satisfy three variations on the monad laws:<div>[<i><a><span>citation needed</span></a></i>]</div>
</p>
<div></div></br><code>(join ∘ (map join)) mmma ↔ (join ∘ join)    mmma ↔ ma</code>
<div></div></br><code>(join ∘ (map unit))  ma   ↔ (join ∘ unit)    ma   ↔ ma</code>  
<div></div></br><code>(join ∘ (map map φ)) mma  ↔ ((map φ) ∘ join) mma  ↔ mb</code>
<p>Regardless of whether a developer defines a direct monad or a Kleisli triple, the underlying structure will be the same, and the forms can be derived from each other easily:
</p>
<div></div></br><code>(map φ) ma  ↔ ma >>= (unit ∘ φ)</code>
<div></div></br><code>join(mma)   ↔ mma >>= id</code>
<div></div></br><code>ma >>= f ↔ (join ∘ (map f)) ma</code><div><a>[28]</a></div>
<div><span>Another example: List <span></span></span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>The <b>List monad</b> naturally demonstrates how deriving a monad from a simpler functor can come in handy.
In many languages, a list structure comes pre-defined along with some basic features, so a <code>List</code> type constructor and <span><a>append</a></span> operator (represented with <code>++</code> for infix notation) are assumed as already given here.
</p><p>Embedding a plain value in a list is also trivial in most languages:
</p>
<div>unit(x)  =  [x]
</div>
<p>From here, applying a function iteratively with a <a>list comprehension</a> may seem like an easy choice for <span>bind</span> and converting lists to a full monad.
The difficulty with this approach is that <span>bind</span> expects monadic functions, which in this case will output lists themselves;
as more functions are applied, layers of nested lists will accumulate, requiring more than a basic comprehension.
</p><p>However, a procedure to apply any <i>simple</i> function over the whole list, in other words <span>map</span>, is straightforward:
</p>
<div>(map φ) xlist  =  [ φ(x1), φ(x2), ..., φ(xn) ]
</div>
<p>Now, these two procedures already promote <code>List</code> to an applicative functor.
To fully qualify as a monad, only a correct notion of <span>join</span> to flatten repeated structure is needed, but for lists, that just means unwrapping an outer list to append the inner ones that contain values:
</p>
<div>join(xlistlist)  =  join([xlist1, xlist2, ..., xlistn])
                 =  xlist1 ++ xlist2 ++ ... ++ xlistn
</div>
<p>The resulting monad is not only a list, but one that automatically resizes and condenses itself as functions are applied.
<span>bind</span> can now also be derived with just a formula, then used to feed <code>List</code> values through a pipeline of monadic functions:
</p>
</br></br><a><div></div></a>  </br></br><a></a>The <code>List</code> monad can greatly simplify the use of multivalued functions, such as complex roots.<div><a>[29]</a></div>
<div>(xlist >>= f)  =  join ∘ (map f) xlist
</div>
<p>One application for this monadic list is representing <a>nondeterministic computation</a>.
<code>List</code> can hold results for all execution paths in an algorithm, then condense itself at each step to "forget" which paths led to which results (a sometimes important distinction from deterministic, exhaustive algorithms).<div>[<i><a><span>citation needed</span></a></i>]</div>
Another benefit is that checks can be embedded in the monad; specific paths can be pruned transparently at their first point of failure, with no need to rewrite functions in the pipeline.<div><a>[28]</a></div>
</p><p>A second situation where <code>List</code> shines is composing <a>multivalued functions</a>.
For instance, the <span>n</span>th <a>complex root</a> of a number should yield <span>n</span> distinct complex numbers, but if another <span>m</span>th root is then taken of those results, the final <span>m•n</span> values should be identical to the output of the <span>m•n</span>th root.
<code>List</code> completely automates this issue away, condensing the results from each step into a flat, mathematically correct list.<div><a>[29]</a></div>
</p>
<div><span>Techniques</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Monads present opportunities for interesting techniques beyond just organizing program logic. Monads can lay the groundwork for useful syntactic features while their high-level and mathematical nature enable significant abstraction.
</p>
<div><span>Syntactic sugar <style>.mw-parser-output .vanchor>:target~.vanchor-text{background-color:#b1d2ff}</style><span><span></span><span>do-notation</span></span></span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Although using <span>bind</span> openly often makes sense, many programmers prefer a syntax that mimics imperative statements
(called <i>do-notation</i> in Haskell, <i>perform-notation</i> in <a>OCaml</a>, <i>computation expressions</i> in <a>F#</a>,<div><a>[30]</a></div> and <i>for comprehension</i> in <a>Scala</a>). This is only <a>syntactic sugar</a> that disguises a monadic pipeline as a <a>code block</a>; the compiler will then quietly translate these expressions into underlying functional code.
</p><p>Translating the <code>add</code> function from the <code>Maybe</code> into Haskell can show this feature in action. A non-monadic version of <code>add</code> in Haskell looks like this:
</p>
</br><div><span></span><span>add</span> <span>mx</span> <span>my</span> <span>=</span>
    <span>case</span> <span>mx</span> <span>of</span>
        <span>Nothing</span> <span>-></span> <span>Nothing</span>
        <span>Just</span> <span>x</span>  <span>-></span> <span>case</span> <span>my</span> <span>of</span>
                       <span>Nothing</span> <span>-></span> <span>Nothing</span>
                       <span>Just</span> <span>y</span>  <span>-></span> <span>Just</span> <span>(</span><span>x</span> <span>+</span> <span>y</span><span>)</span>
</div>
<p>In monadic Haskell, <code>return</code> is the standard name for <span>unit</span>, plus lambda expressions must be handled explicitly, but even with these technicalities, the <code>Maybe</code> monad makes for a cleaner definition:
</p>
</br><div><span></span><span>add</span> <span>mx</span> <span>my</span> <span>=</span>
    <span>mx</span> <span>>>=</span> <span>(</span><span>\</span><span>x</span> <span>-></span>
        <span>my</span> <span>>>=</span> <span>(</span><span>\</span><span>y</span> <span>-></span>
            <span>return</span> <span>(</span><span>x</span> <span>+</span> <span>y</span><span>)))</span>
</div>
<p>With do-notation though, this can be distilled even further into a very intuitive sequence:
</p>
</br><div><span></span><span>add</span> <span>mx</span> <span>my</span> <span>=</span> <span>do</span>
    <span>x</span> <span><-</span> <span>mx</span>
    <span>y</span> <span><-</span> <span>my</span>
    <span>return</span> <span>(</span><span>x</span> <span>+</span> <span>y</span><span>)</span>
</div>
<p>A second example shows how <code>Maybe</code> can be used in an entirely different language: F#.
With computation expressions, a "safe division" function that returns <code>None</code> for an undefined operand <i>or</i> division by zero can be written as:
</p>
</br><div><span></span><span>let</span> <span>readNum</span> <span>()</span> <span>=</span>
  <span>let</span> <span>s</span> <span>=</span> <span>Console</span><span>.</span><span>ReadLine</span><span>()</span>
  <span>let</span> <span>succ</span><span>,</span><span>v</span> <span>=</span> <span>Int32</span><span>.</span><span>TryParse</span><span>(</span><span>s</span><span>)</span>
  <span>if</span> <span>(</span><span>succ</span><span>)</span> <span>then</span> <span>Some</span><span>(</span><span>v</span><span>)</span> <span>else</span> <span>None</span>

<span>let</span> <span>secure_div</span> <span>=</span> 
  <span>maybe</span> <span>{</span> 
    <span>let</span><span>!</span> <span>x</span> <span>=</span> <span>readNum</span><span>()</span>
    <span>let</span><span>!</span> <span>y</span> <span>=</span> <span>readNum</span><span>()</span>
    <span>if</span> <span>(</span><span>y</span> <span>=</span> <span>0</span><span>)</span> 
    <span>then</span> <span>None</span>
    <span>else</span> <span>return</span> <span>(</span><span>x</span> <span>/</span> <span>y</span><span>)</span>
  <span>}</span>
</div>
<p>At build-time, the compiler will internally "de-sugar" this function into a denser chain of <span>bind</span> calls:
</p>
</br><div><span></span><span>maybe</span><span>.</span><span>Delay</span><span>(</span><span>fun</span> <span>()</span> <span>-></span>
  <span>maybe</span><span>.</span><span>Bind</span><span>(</span><span>readNum</span><span>()</span><span>,</span> <span>fun</span> <span>x</span> <span>-></span>
    <span>maybe</span><span>.</span><span>Bind</span><span>(</span><span>readNum</span><span>()</span><span>,</span> <span>fun</span> <span>y</span> <span>-></span>
      <span>if</span> <span>(</span><span>y</span><span>=</span><span>0</span><span>)</span> <span>then</span> <span>None</span> <span>else</span> <span>maybe</span><span>.</span><span>Return</span><span>(</span><span>x</span> <span>/</span> <span>y</span><span>))))</span>
</div>
<p>For a last example, even the general monad laws themselves can be expressed in do-notation:
</p>
</br><div><span></span><span>do</span> <span>{</span> <span>x</span> <span><-</span> <span>return</span> <span>v</span><span>;</span> <span>f</span> <span>x</span> <span>}</span>            <span>==</span>  <span>do</span> <span>{</span> <span>f</span> <span>v</span> <span>}</span>
<span>do</span> <span>{</span> <span>x</span> <span><-</span> <span>m</span><span>;</span> <span>return</span> <span>x</span> <span>}</span>              <span>==</span>  <span>do</span> <span>{</span> <span>m</span> <span>}</span>
<span>do</span> <span>{</span> <span>y</span> <span><-</span> <span>do</span> <span>{</span> <span>x</span> <span><-</span> <span>m</span><span>;</span> <span>f</span> <span>x</span> <span>};</span> <span>g</span> <span>y</span> <span>}</span>  <span>==</span>  <span>do</span> <span>{</span> <span>x</span> <span><-</span> <span>m</span><span>;</span> <span>y</span> <span><-</span> <span>f</span> <span>x</span><span>;</span> <span>g</span> <span>y</span> <span>}</span>
</div>
<p>While convenient, a developer should always remember that this block style is purely syntactic and can be replaced with outwardly monadic (or even non-monadic CPS) expressions.
Using <span>bind</span> to express the monadic pipeline can still be clearer in many cases, and some functional programming advocates even argue that since block-style allows novices to carry over habits from imperative programming, it should be avoided by default and only used when obviously superior.<div><a>[31]</a></div><div><a>[1]</a></div>
</p>
<div><span>General interface</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Every monad needs a specific implementation that meets the monad laws, but other aspects like the relation to other structures or standard idioms within a language are shared by all monads.
As a result, a language or library may provide a general <code>Monad</code> interface with <a>function prototypes</a>, subtyping relationships, and other general facts.
Besides providing a head-start to development and guaranteeing a new monad inherits features from a supertype (such as functors), checking a monad's design against the interface adds another layer of quality control.<div>[<i><a><span>citation needed</span></a></i>]</div>
</p>
<div><span>Operators <span></span><span></span></span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Monadic code can often be simplified even further through the judicious use of operators.
The <span>map</span> functional can be especially helpful since it works on more than just ad-hoc monadic functions; so long as a monadic function should work analogously to a predefined operator, <span>map</span> can be used to instantly "<a>lift</a>" the simpler operator into a monadic one.<div><a>[k]</a></div>
With this technique, the definition of <code>add</code> from the <code>Maybe</code> example could be distilled into:
</p>
<div>add(mx,my)  =  map (+)
</div>
<p>The process could be taken even one step further by defining <code>add</code> not just for <code>Maybe</code>, but for the whole <code>Monad</code> interface.
By doing this, any new monad that matches the structure interface and implements its own <span>map</span> will immediately inherit a lifted version of <code>add</code> too.
The only change to the function needed is generalizing the type signature:
</p>
<div>add : (Monad Number, Monad Number)  →  Monad Number<div><a>[32]</a></div>
</div>
<p>Another monadic operator that is also useful for analysis is monadic composition (represented as infix <code>>=></code> here), which allows chaining monadic functions in a more mathematical style:
</p>
<div>(f >=> g)(x) =  f(x) >>= g
</div>
<p>With this operator, the monad laws can be written in terms of functions alone, highlighting the correspondence to associativity and existence of an identity:
</p>
<div>(unit >=> g)     ↔  g
(f >=> unit)     ↔  f
(f >=> g) >=> h  ↔  f >=> (g >=> h)<div><a>[1]</a></div>
</div>
<p>In turn, the above shows the meaning of the "do" block in Haskell:
</p>
<div>do
 _p <- f(x)
 _q <- g(_p)
 h(_q)          ↔ ( f >=> g >=> h )(x)
</div>
<div><span>More examples</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<div><span>Identity monad</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>The simplest monad is the <b>Identity monad</b>, which just annotates plain values and functions to satisfy the monad laws:
</p>
<div><b>newtype</b> Id T  =  T

unit(x)    =  x
(x >>= f)  =  f(x)
</div>
<p><code>Identity</code> does actually have valid uses though, such as providing a <a>base case</a> for recursive <a>monad transformers</a>.
It can also be used to perform basic variable assignment within an imperative-style block.<div><a>[l]</a></div><div>[<i><a><span>citation needed</span></a></i>]</div>
</p>
<div><span>Collections</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Any collection with a proper <span>append</span> is already a free monoid, but it turns out that <code>List</code> is not the only <a>collection</a> that also has a well-defined <span>join</span> and qualifies as a monad.
One can even mutate <code>List</code> into these other monadic collections by simply imposing special properties on <span>append</span>:<div><a>[m]</a></div><div><a>[n]</a></div>
</p>


<div><div>
<div>Collection
</div>
<div>Monoid properties
</div></div>
<div>
<div>List
</div>
<div>Free
</div></div>
<div>
<div>Finite <a>multiset</a>
</div>
<div><a>Commutative</a>
</div></div>
<div>
<div>Finite set
</div>
<div>Commutative and <a>idempotent</a>
</div></div>
<div>
<div>Finite <a>permutations</a>
</div>
<div>Non-commutative and idempotent
</div></div></div></table>
<div><span></span><span>IO monad (Haskell) <span></span></span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>As already mentioned, pure code should not have unmanaged side effects, but that does not preclude a program from <i>explicitly</i> describing and managing effects.
This idea is central to Haskell's <b>IO monad</b>, where an object of type <code>IO a</code> can be seen as describing an action to be performed in the world, optionally providing information about the world of type <code>a</code>. An action that provides no information about the world has the type <code>IO ()</code>, "providing" the dummy value <code>()</code>.
When a programmer binds an <code>IO</code> value to a function, the function computes the next action to be performed based on the information about the world provided by the previous action (input from users, files, etc.).<div><a>[23]</a></div> Most significantly, because the value of the IO monad can only be bound to a function that computes another IO monad, the bind function imposes a discipline of a sequence of actions where the result of an action can only be provided to a function that will compute the next action to perform. This means that actions which do not need to be performed never are, and actions that do need to be performed have a well defined sequence, solving the problem of (IO) actions not being <a>referentially transparent</a>.
</p><p>For example, Haskell has several functions for acting on the wider <a>file system</a>, including one that checks whether a file exists and another that deletes a file.
Their two type signatures are:
</p>
</br><div><span></span><span>doesFileExist</span> <span>::</span> <span>FilePath</span> <span>-></span> <span>IO</span> <span>Bool</span>
<span>removeFile</span> <span>::</span> <span>FilePath</span> <span>-></span> <span>IO</span> <span>()</span>
</div>
<p>The first is interested in whether a given file really exists, and as a result, outputs a <a>Boolean value</a> within the <code>IO</code> monad.
The second function, on the other hand, is only concerned with acting on the file system so the <code>IO</code> container it outputs is empty.
</p><p><code>IO</code> is not limited just to file I/O though; it even allows for user I/O, and along with imperative syntax sugar, can mimic a typical <a>"Hello, World!" program</a>:
</p>
</br><div><span></span><span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
  <span>putStrLn</span> <span>"Hello, world!"</span>
  <span>putStrLn</span> <span>"What is your name, user?"</span>
  <span>name</span> <span><-</span> <span>getLine</span>
  <span>putStrLn</span> <span>(</span><span>"Nice to meet you, "</span> <span>++</span> <span>name</span> <span>++</span> <span>"!"</span><span>)</span>
</div>
<p>Desugared, this translates into the following monadic pipeline (<code>>></code> in Haskell is just a variant of <span>bind</span> for when only monadic effects matter and the underlying result can be discarded):
</p>
</br><div><span></span><span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span>
  <span>putStrLn</span> <span>"Hello, world!"</span> <span>>></span>
  <span>putStrLn</span> <span>"What is your name, user?"</span> <span>>></span> 
  <span>getLine</span> <span>>>=</span> <span>(</span><span>\</span><span>name</span> <span>-></span>
    <span>putStrLn</span> <span>(</span><span>"Nice to meet you, "</span> <span>++</span> <span>name</span> <span>++</span> <span>"!"</span><span>))</span>
</div>
<div><span></span><span>Writer monad (JavaScript) <span></span></span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Another common situation is keeping a <a>log file</a> or otherwise reporting a program's progress.
Sometimes, a programmer may want to log even more specific, technical data for later <a>profiling</a> or <a>debugging</a>.
The <b>Writer monad</b> can handle these tasks by generating auxiliary output that accumulates step-by-step.
</p><p>To show how the monad pattern is not restricted to primarily functional languages, this example implements a <code>Writer</code> monad in <a>JavaScript</a>.
First, an array (with nested tails) allows constructing the <code>Writer</code> type as a <a>linked list</a>.
The underlying output value will live in position 0 of the array, and position 1 will implicitly hold a chain of auxiliary notes:
</p>
</br><div><span></span><span>const</span> <span>writer</span> <span>=</span> <span>value</span> <span>=></span> <span>[</span><span>value</span><span>,</span> <span>[]];</span>
</div>
<p>Defining <span>unit</span> is also very simple:
</p>
</br><div><span></span><span>const</span> <span>unit</span> <span>=</span> <span>value</span> <span>=></span> <span>[</span><span>value</span><span>,</span> <span>[]];</span>
</div>
<p>Only <span>unit</span> is needed to define simple functions that output <code>Writer</code> objects with debugging notes:
</p>
</br><div><span></span><span>const</span> <span>squared</span> <span>=</span> <span>x</span> <span>=></span> <span>[</span><span>x</span> <span>*</span> <span>x</span><span>,</span> <span>[</span><span>`</span><span>${</span><span>x</span><span>}</span><span> was squared.`</span><span>]];</span>
<span>const</span> <span>halved</span> <span>=</span> <span>x</span> <span>=></span> <span>[</span><span>x</span> <span>/</span> <span>2</span><span>,</span> <span>[</span><span>`</span><span>${</span><span>x</span><span>}</span><span> was halved.`</span><span>]];</span>
</div>
<p>A true monad still requires <span>bind</span>, but for <code>Writer</code>, this amounts simply to concatenating a function's output to the monad's linked list:
</p>
</br><div><span></span><span>const</span> <span>bind</span> <span>=</span> <span>(</span><span>writer</span><span>,</span> <span>transform</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> <span>[</span><span>value</span><span>,</span> <span>log</span><span>]</span> <span>=</span> <span>writer</span><span>;</span>
    <span>const</span> <span>[</span><span>result</span><span>,</span> <span>updates</span><span>]</span> <span>=</span> <span>transform</span><span>(</span><span>value</span><span>);</span>
    <span>return</span> <span>[</span><span>result</span><span>,</span> <span>log</span><span>.</span><span>concat</span><span>(</span><span>updates</span><span>)];</span>
<span>};</span>
</div>
<p>The sample functions can now be chained together using <span>bind</span>, but defining a version of monadic composition (called <code>pipelog</code> here) allows applying these functions even more succinctly:
</p>
</br><div><span></span><span>const</span> <span>pipelog</span> <span>=</span> <span>(</span><span>writer</span><span>,</span> <span>...</span><span>transforms</span><span>)</span> <span>=></span>
    <span>transforms</span><span>.</span><span>reduce</span><span>(</span><span>bind</span><span>,</span> <span>writer</span><span>);</span>
</div>
<p>The final result is a clean separation of concerns between stepping through computations and logging them to audit later: 
</p>
</br><div><span></span><span>pipelog</span><span>(</span><span>unit</span><span>(</span><span>4</span><span>),</span> <span>squared</span><span>,</span> <span>halved</span><span>);</span>
<span>// Resulting writer object = [8, ['4 was squared.', '16 was halved.']]</span>
</div>
<div><span>Environment monad</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>An environment monad (also called a <i>reader monad</i> and a <i>function monad</i>) allows a computation to depend on values from a shared environment. The monad type constructor maps a type <span>T</span> to functions of type <span><i>E</i> → <i>T</i></span>, where <span>E</span> is the type of the shared environment. The monad functions are:
</p></br></br><div>
  <div>
    <div>
      <div>
        <div>
          <div>
            <div>
              <div>
                <div>
                  <div>return</div>
                </div>
                <div>:</div>
              </div>
              <div>
                <div>T</div>
                <div>→</div>
                <div>E</div>
                <div>→</div>
                <div>T</div>
                <div>=</div>
                <div>t</div>
                <div>↦</div>
                <div>e</div>
                <div>↦</div>
                <div>t</div>
              </div>
            </div>
            <div>
              <div>
                <div>
                  <div>bind</div>
                </div>
                <div>:</div>
              </div>
              <div>
                <div>(</div>
                <div>E</div>
                <div>→</div>
                <div>T</div>
                <div>)</div>
                <div>→</div>
                <div>(</div>
                <div>T</div>
                <div>→</div>
                <div>E</div>
                <div>→</div>
                <div>
                  <div>T</div>
                  <div>′</div>
                </div>
                <div>)</div>
                <div>→</div>
                <div>E</div>
                <div>→</div>
                <div>
                  <div>T</div>
                  <div>′</div>
                </div>
                <div>=</div>
                <div>r</div>
                <div>↦</div>
                <div>f</div>
                <div>↦</div>
                <div>e</div>
                <div>↦</div>
                <div>f</div>
                <div></div>
                <div>(</div>
                <div>r</div>
                <div></div>
                <div>e</div>
                <div>)</div>
                <div></div>
                <div>e</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div>{\displaystyle {\begin{array}{ll}{\text{return}}\colon &T\rightarrow E\rightarrow T=t\mapsto e\mapsto t\\{\text{bind}}\colon &(E\rightarrow T)\rightarrow (T\rightarrow E\rightarrow T')\rightarrow E\rightarrow T'=r\mapsto f\mapsto e\mapsto f\,(r\,e)\,e\end{array}}}</div>
  </div>
</div><div></div>
<p></p><p>The following monadic operations are useful:
</p></br></br><div>
  <div>
    <div>
      <div>
        <div>
          <div>
            <div>
              <div>
                <div>
                  <div>ask</div>
                </div>
                <div>:</div>
              </div>
              <div>
                <div>E</div>
                <div>→</div>
                <div>E</div>
                <div>=</div>
                <div>
                  <div>
                    <div>id</div>
                  </div>
                  <div>
                    <div>E</div>
                  </div>
                </div>
              </div>
            </div>
            <div>
              <div>
                <div>
                  <div>local</div>
                </div>
                <div>:</div>
              </div>
              <div>
                <div>(</div>
                <div>E</div>
                <div>→</div>
                <div>E</div>
                <div>)</div>
                <div>→</div>
                <div>(</div>
                <div>E</div>
                <div>→</div>
                <div>T</div>
                <div>)</div>
                <div>→</div>
                <div>E</div>
                <div>→</div>
                <div>T</div>
                <div>=</div>
                <div>f</div>
                <div>↦</div>
                <div>c</div>
                <div>↦</div>
                <div>e</div>
                <div>↦</div>
                <div>c</div>
                <div></div>
                <div>(</div>
                <div>f</div>
                <div></div>
                <div>e</div>
                <div>)</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div>{\displaystyle {\begin{array}{ll}{\text{ask}}\colon &E\rightarrow E={\text{id}}_{E}\\{\text{local}}\colon &(E\rightarrow E)\rightarrow (E\rightarrow T)\rightarrow E\rightarrow T=f\mapsto c\mapsto e\mapsto c\,(f\,e)\end{array}}}</div>
  </div>
</div><div></div>
<p></p><p>The <span>ask</span> operation is used to retrieve the current context, while <span>local</span> executes a computation in a modified subcontext. As in a state monad, computations in the environment monad may be invoked by simply providing an environment value and applying it to an instance of the monad.
</p><p>Formally, a value in an environment monad is equivalent to a function with an additional, anonymous argument; <span>return</span> and <span>bind</span> are equivalent to the <span>K</span> and <span>S</span> combinators, respectively, in the <a>SKI combinator calculus</a>.
</p>
<div><span>State monads</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>A state monad allows a programmer to attach state information of any type to a calculation. Given any value type, the corresponding type in the state monad is a function which accepts a state, then outputs a new state (of type <code>s</code>) along with a return value (of type <code>t</code>). This is similar to an environment monad, except that it also returns a new state, and thus allows modeling a <i>mutable</i> environment.
</p>
</br><div><span></span><span>type</span> <span>State</span> <span>s</span> <span>t</span> <span>=</span> <span>s</span> <span>-></span> <span>(</span><span>t</span><span>,</span> <span>s</span><span>)</span>
</div>
<p>Note that this monad takes a type parameter, the type of the state information. The monad operations are defined as follows:
</p>
</br><div><span></span><span>-- "return" produces the given value without changing the state.</span>
<span>return</span> <span>x</span> <span>=</span> <span>\</span><span>s</span> <span>-></span> <span>(</span><span>x</span><span>,</span> <span>s</span><span>)</span>
<span>-- "bind" modifies m so that it applies f to its result.</span>
<span>m</span> <span>>>=</span> <span>f</span> <span>=</span> <span>\</span><span>r</span> <span>-></span> <span>let</span> <span>(</span><span>x</span><span>,</span> <span>s</span><span>)</span> <span>=</span> <span>m</span> <span>r</span> <span>in</span> <span>(</span><span>f</span> <span>x</span><span>)</span> <span>s</span>
</div>
<p>Useful state operations include:
</p>
</br><div><span></span><span>get</span> <span>=</span> <span>\</span><span>s</span> <span>-></span> <span>(</span><span>s</span><span>,</span> <span>s</span><span>)</span> <span>-- Examine the state at this point in the computation.</span>
<span>put</span> <span>s</span> <span>=</span> <span>\</span><span>_</span> <span>-></span> <span>(</span><span>()</span><span>,</span> <span>s</span><span>)</span> <span>-- Replace the state.</span>
<span>modify</span> <span>f</span> <span>=</span> <span>\</span><span>s</span> <span>-></span> <span>(</span><span>()</span><span>,</span> <span>f</span> <span>s</span><span>)</span> <span>-- Update the state</span>
</div>
<p>Another operation applies a state monad to a given initial state:
</p>
</br><div><span></span><span>runState</span> <span>::</span> <span>State</span> <span>s</span> <span>a</span> <span>-></span> <span>s</span> <span>-></span> <span>(</span><span>a</span><span>,</span> <span>s</span><span>)</span>
<span>runState</span> <span>t</span> <span>s</span> <span>=</span> <span>t</span> <span>s</span>
</div>
<p>do-blocks in a state monad are sequences of operations that can examine and update the state data.
</p><p>Informally, a state monad of state type <span>S</span> maps the type of return values <span>T</span> into functions of type <span><span><div>
  <div>
    <div>
      <div>
        <div>S</div>
        <div>→</div>
        <div>T</div>
        <div>×</div>
        <div>S</div>
      </div>
    </div>
    <div>{\displaystyle S\rightarrow T\times S}</div>
  </div>
</div></span><div></div></span>, where <span>S</span> is the underlying state. The <span>return</span> and <span>bind</span> function are:
</p>
<div><div><span><span><div>
  <div>
    <div>
      <div>
        <div>
          <div>
            <div>
              <div>
                <div>
                  <div>return</div>
                </div>
                <div>:</div>
              </div>
              <div>
                <div>T</div>
                <div>→</div>
                <div>S</div>
                <div>→</div>
                <div>T</div>
                <div>×</div>
                <div>S</div>
                <div>=</div>
                <div>t</div>
                <div>↦</div>
                <div>s</div>
                <div>↦</div>
                <div>(</div>
                <div>t</div>
                <div>,</div>
                <div>s</div>
                <div>)</div>
              </div>
            </div>
            <div>
              <div>
                <div>
                  <div>bind</div>
                </div>
                <div>:</div>
              </div>
              <div>
                <div>(</div>
                <div>S</div>
                <div>→</div>
                <div>T</div>
                <div>×</div>
                <div>S</div>
                <div>)</div>
                <div>→</div>
                <div>(</div>
                <div>T</div>
                <div>→</div>
                <div>S</div>
                <div>→</div>
                <div>
                  <div>T</div>
                  <div>′</div>
                </div>
                <div>×</div>
                <div>S</div>
                <div>)</div>
                <div>→</div>
                <div>S</div>
                <div>→</div>
                <div>
                  <div>T</div>
                  <div>′</div>
                </div>
                <div>×</div>
                <div>S</div>
                <div> </div>
                <div>=</div>
                <div>m</div>
                <div>↦</div>
                <div>k</div>
                <div>↦</div>
                <div>s</div>
                <div>↦</div>
                <div>(</div>
                <div>k</div>
                <div> </div>
                <div>t</div>
                <div> </div>
                <div>
                  <div>s</div>
                  <div>′</div>
                </div>
                <div>)</div>
                <div></div>
                <div>
                  <div>where</div>
                </div>
                <div></div>
                <div>(</div>
                <div>t</div>
                <div>,</div>
                <div>
                  <div>s</div>
                  <div>′</div>
                </div>
                <div>)</div>
                <div>=</div>
                <div>m</div>
                <div></div>
                <div>s</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div>{\displaystyle {\begin{array}{ll}{\text{return}}\colon &T\rightarrow S\rightarrow T\times S=t\mapsto s\mapsto (t,s)\\{\text{bind}}\colon &(S\rightarrow T\times S)\rightarrow (T\rightarrow S\rightarrow T'\times S)\rightarrow S\rightarrow T'\times S\ =m\mapsto k\mapsto s\mapsto (k\ t\ s')\quad {\text{where}}\;(t,s')=m\,s\end{array}}}</div>
  </div>
</div></span><div></div></span>.</div></div>
<p>From the category theory point of view, a state monad is derived from the adjunction between the product functor and the exponential functor, which exists in any <a>cartesian closed category</a> by definition.
</p>
<div><span>Continuation monad</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>A <a>continuation</a> monad<div><a>[o]</a></div> with return type <span>R</span> maps type <span>T</span> into functions of type <span><span><div>
  <div>
    <div>
      <div>
        <div>
          <div>(</div>
          <div>
            <div>T</div>
            <div>→</div>
            <div>R</div>
          </div>
          <div>)</div>
        </div>
        <div>→</div>
        <div>R</div>
      </div>
    </div>
    <div>{\displaystyle \left(T\rightarrow R\right)\rightarrow R}</div>
  </div>
</div></span><div></div></span>. It is used to model <a>continuation-passing style</a>. The return and bind functions are as follows:
</p>
<div><div><span><span><div>
  <div>
    <div>
      <div>
        <div>
          <div>
            <div>
              <div>
                <div>
                  <div>return</div>
                </div>
                <div>:</div>
              </div>
              <div>
                <div>T</div>
                <div>→</div>
                <div>
                  <div>(</div>
                  <div>
                    <div>T</div>
                    <div>→</div>
                    <div>R</div>
                  </div>
                  <div>)</div>
                </div>
                <div>→</div>
                <div>R</div>
                <div>=</div>
                <div>t</div>
                <div>↦</div>
                <div>f</div>
                <div>↦</div>
                <div>f</div>
                <div></div>
                <div>t</div>
              </div>
            </div>
            <div>
              <div>
                <div>
                  <div>bind</div>
                </div>
                <div>:</div>
              </div>
              <div>
                <div>
                  <div>(</div>
                  <div>
                    <div>
                      <div>(</div>
                      <div>
                        <div>T</div>
                        <div>→</div>
                        <div>R</div>
                      </div>
                      <div>)</div>
                    </div>
                    <div>→</div>
                    <div>R</div>
                  </div>
                  <div>)</div>
                </div>
                <div>→</div>
                <div>
                  <div>(</div>
                  <div>
                    <div>T</div>
                    <div>→</div>
                    <div>
                      <div>(</div>
                      <div>
                        <div>
                          <div>T</div>
                          <div>′</div>
                        </div>
                        <div>→</div>
                        <div>R</div>
                      </div>
                      <div>)</div>
                    </div>
                    <div>→</div>
                    <div>R</div>
                  </div>
                  <div>)</div>
                </div>
                <div>→</div>
                <div>
                  <div>(</div>
                  <div>
                    <div>
                      <div>T</div>
                      <div>′</div>
                    </div>
                    <div>→</div>
                    <div>R</div>
                  </div>
                  <div>)</div>
                </div>
                <div>→</div>
                <div>R</div>
                <div>=</div>
                <div>c</div>
                <div>↦</div>
                <div>f</div>
                <div>↦</div>
                <div>k</div>
                <div>↦</div>
                <div>c</div>
                <div></div>
                <div>
                  <div>(</div>
                  <div>
                    <div>t</div>
                    <div>↦</div>
                    <div>f</div>
                    <div></div>
                    <div>t</div>
                    <div></div>
                    <div>k</div>
                  </div>
                  <div>)</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div>{\displaystyle {\begin{array}{ll}{\text{return}}\colon &T\rightarrow \left(T\rightarrow R\right)\rightarrow R=t\mapsto f\mapsto f\,t\\{\text{bind}}\colon &\left(\left(T\rightarrow R\right)\rightarrow R\right)\rightarrow \left(T\rightarrow \left(T'\rightarrow R\right)\rightarrow R\right)\rightarrow \left(T'\rightarrow R\right)\rightarrow R=c\mapsto f\mapsto k\mapsto c\,\left(t\mapsto f\,t\,k\right)\end{array}}}</div>
  </div>
</div></span><div></div></span></div></div>
<p>The <a>call-with-current-continuation</a> function is defined as follows:
</p>
<div><div><span><span><div>
  <div>
    <div>
      <div>
        <div>
          <div>call/cc</div>
        </div>
        <div>:</div>
        <div> </div>
        <div>
          <div>(</div>
          <div>
            <div>
              <div>(</div>
              <div>
                <div>T</div>
                <div>→</div>
                <div>
                  <div>(</div>
                  <div>
                    <div>
                      <div>T</div>
                      <div>′</div>
                    </div>
                    <div>→</div>
                    <div>R</div>
                  </div>
                  <div>)</div>
                </div>
                <div>→</div>
                <div>R</div>
              </div>
              <div>)</div>
            </div>
            <div>→</div>
            <div>
              <div>(</div>
              <div>
                <div>T</div>
                <div>→</div>
                <div>R</div>
              </div>
              <div>)</div>
            </div>
            <div>→</div>
            <div>R</div>
          </div>
          <div>)</div>
        </div>
        <div>→</div>
        <div>
          <div>(</div>
          <div>
            <div>T</div>
            <div>→</div>
            <div>R</div>
          </div>
          <div>)</div>
        </div>
        <div>→</div>
        <div>R</div>
        <div>=</div>
        <div>f</div>
        <div>↦</div>
        <div>k</div>
        <div>↦</div>
        <div>
          <div>(</div>
          <div>
            <div>f</div>
            <div>
              <div>(</div>
              <div>
                <div>t</div>
                <div>↦</div>
                <div>x</div>
                <div>↦</div>
                <div>k</div>
                <div></div>
                <div>t</div>
              </div>
              <div>)</div>
            </div>
            <div></div>
            <div>k</div>
          </div>
          <div>)</div>
        </div>
      </div>
    </div>
    <div>{\displaystyle {\text{call/cc}}\colon \ \left(\left(T\rightarrow \left(T'\rightarrow R\right)\rightarrow R\right)\rightarrow \left(T\rightarrow R\right)\rightarrow R\right)\rightarrow \left(T\rightarrow R\right)\rightarrow R=f\mapsto k\mapsto \left(f\left(t\mapsto x\mapsto k\,t\right)\,k\right)}</div>
  </div>
</div></span><div></div></span></div></div>
<div><span>Program logging</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>The following code is pseudocode. <span></span>Suppose we have two functions <code>foo</code> and <code>bar</code>, with types 
</p>
</br><div><span></span><span>foo</span> <span>:</span> <span>int</span> <span>-></span> <span>int</span>
<span>bar</span> <span>:</span> <span>int</span> <span>-></span> <span>int</span>
</div>
<p>That is, both functions take in an integer and return another integer. Then we can apply the functions in succession like so:
</p>
</br><div><span></span><span>foo</span> <span>(</span><span>bar</span> <span>x</span><span>)</span>
</div>
<p>Where the result is the result of <code>foo</code> applied to the result of <code>bar</code> applied to <code>x</code>.
</p><p>But suppose we are debugging our program, and we would like to add logging messages to <code>foo</code> and <code>bar</code>.
So we change the types as so:
</p>
</br><div><span></span><span>foo</span> <span>:</span> <span>int</span> <span>-></span> <span>int</span> <span>*</span> <span>string</span>
<span>bar</span> <span>:</span> <span>int</span> <span>-></span> <span>int</span> <span>*</span> <span>string</span>
</div>
<p>So that both functions return a tuple, with the result of the application as the integer, 
and a logging message with information about the applied function and all the previously applied functions as the string.
</p><p>Unfortunately, this means we can no longer <a>compose</a> <code>foo</code> and <code>bar</code>, as their input type <code>int</code> is not compatible with their output type <code>int * string</code>. And although we can again gain composability by modifying the types of each function to be <code>int * string -> int * string</code>, this would require us to add boilerplate code to each function to extract the integer from the tuple, which would get tedious as the number of such functions increases.
</p><p><span></span>
Instead, let us define a helper function to abstract away this boilerplate for us:
</p>
</br><div><span></span><span>bind</span> <span>:</span> <span>int</span> <span>*</span> <span>string</span> <span>-></span> <span>(</span><span>int</span> <span>-></span> <span>int</span> <span>*</span> <span>string</span><span>)</span> <span>-></span> <span>int</span> <span>*</span> <span>string</span>
</div>
<p><code>bind</code> takes in an integer and string tuple, then takes in a function (like <code>foo</code>) that maps from an integer to an integer and string tuple. Its output is an integer and string tuple, which is the result of applying the input function to the integer within the input integer and string tuple. 
In this way, we only need to write boilerplate code to extract the integer from the tuple once, in <code>bind</code>.
</p><p>Now we have regained some composability. For example:
</p>
</br><div><span></span><span>bind</span> <span>(</span><span>bind</span> <span>(</span><span>x</span><span>,</span><span>s</span><span>)</span> <span>bar</span><span>)</span> <span>foo</span>
</div>
<p>Where <code>(x,s)</code> is an integer and string tuple.<div><a>[p]</a></div>
</p><p>To make the benefits even clearer, let us define an infix operator as an alias for <code>bind</code>:
</p>
</br><div><span></span><span>(</span><span>>>=</span><span>)</span> <span>:</span> <span>int</span> <span>*</span> <span>string</span> <span>-></span> <span>(</span><span>int</span> <span>-></span> <span>int</span> <span>*</span> <span>string</span><span>)</span> <span>-></span> <span>int</span> <span>*</span> <span>string</span>
</div>
<p>So that <code>t >>= f</code> is the same as <code>bind t f</code>.
</p><p>Then the above example becomes:
</p>
</br><div><span></span><span>((</span><span>x</span><span>,</span><span>s</span><span>)</span> <span>>>=</span> <span>bar</span><span>)</span> <span>>>=</span> <span>foo</span>
</div>
<p>Finally, it would be nice to not have to write <code>(x, "")</code> every time we wish to create an empty logging message, where <code>""</code> is the empty string.
So let us define a new function:
</p>
</br><div><span></span><span>return</span> <span>:</span> <span>int</span> <span>-></span> <span>int</span> <span>*</span> <span>string</span>
</div>
<p>Which wraps <code>x</code> in the tuple described above.
</p><p>Now we have a nice pipeline for logging messages:
</p>
</br><div><span></span><span>((</span><span>return</span> <span>x</span><span>)</span> <span>>>=</span> <span>bar</span><span>)</span> <span>>>=</span> <span>foo</span>
</div>
<p>That allows us to more easily log the effects of <code>bar</code> and <code>foo</code> on <code>x</code>.
</p><p><code>int * string</code> denotes a pseudo-coded <b>monadic value</b>.<div><a>[p]</a></div> <code>bind</code> and <code>return</code> are analogous to the corresponding functions of the same name.
In fact, <code>int * string</code>, <code>bind</code>, and <code>return</code> form a monad.
</p>
<div><span>Variations</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>At a mathematical level, some monads have particularly nice properties and are uniquely fitted to certain problems.
</p>
<div><span>Additive monads</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>An <b>additive monad</b> is a monad endowed with an additional closed, associative, binary operator <b>mplus</b> and an <a>identity element</a> under <span>mplus</span>, called <b>mzero</b>.
The <code>Maybe</code> monad can be considered additive, with <code>Nothing</code> as <span>mzero</span> and a variation on the <a>OR</a> operator as <span>mplus</span>.
<code>List</code> is also an additive monad, with the empty list <code>[]</code> acting as <span>mzero</span> and the concatenation operator <code>++</code> as <span>mplus</span>.
</p><p>Intuitively, <span>mzero</span> represents a monadic wrapper with no value from an underlying type, but is also considered a "zero" (rather than a "one") since it acts as an <a>absorber</a> for <span>bind</span>, returning <span>mzero</span> whenever bound to a monadic function.
This property is two-sided, and <span>bind</span> will also return <span>mzero</span> when any value is bound to a monadic <a>zero function</a>.
</p><p>In category-theoretic terms, an additive monad qualifies once as a monoid over monadic functions with <span>bind</span> (as all monads do), and again over monadic values via <span>mplus</span>.<div><a>[33]</a></div><div><a>[q]</a></div>
</p>
<div><span>Free monads</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Sometimes, the general outline of a monad may be useful, but no simple pattern recommends one monad or another.
This is where a <b>free monad</b> comes in; as a <a>free object</a> in the category of monads, it can represent monadic structure without any specific constraints beyond the monad laws themselves.
Just as a <a>free monoid</a> concatenates elements without evaluation, a free monad allows chaining computations with markers to satisfy the type system, but otherwise imposes no deeper semantics itself.
</p><p>For example, by working entirely through the <code>Just</code> and <code>Nothing</code> markers, the <code>Maybe</code> monad is in fact a free monad.
The <code>List</code> monad, on the other hand, is not a free monad since it brings extra, specific facts about lists (like <span>append</span>) into its definition.
One last example is an abstract free monad:
</p>
</br><div><span></span><span>data</span> <span>Free</span> <span>f</span> <span>a</span>
  <span>=</span> <span>Pure</span> <span>a</span>
  <span>|</span> <span>Free</span> <span>(</span><span>f</span> <span>(</span><span>Free</span> <span>f</span> <span>a</span><span>))</span>

<span>unit</span> <span>::</span> <span>a</span> <span>-></span> <span>Free</span> <span>f</span> <span>a</span>
<span>unit</span> <span>x</span> <span>=</span> <span>Pure</span> <span>x</span>

<span>bind</span> <span>::</span> <span>Functor</span> <span>f</span> <span>=></span> <span>Free</span> <span>f</span> <span>a</span> <span>-></span> <span>(</span><span>a</span> <span>-></span> <span>Free</span> <span>f</span> <span>b</span><span>)</span> <span>-></span> <span>Free</span> <span>f</span> <span>b</span>
<span>bind</span> <span>(</span><span>Pure</span> <span>x</span><span>)</span> <span>f</span> <span>=</span> <span>f</span> <span>x</span>
<span>bind</span> <span>(</span><span>Free</span> <span>x</span><span>)</span> <span>f</span> <span>=</span> <span>Free</span> <span>(</span><span>fmap</span> <span>(</span><span>\</span><span>y</span> <span>-></span> <span>bind</span> <span>y</span> <span>f</span><span>)</span> <span>x</span><span>)</span>
</div>
<p>Free monads, however, are <i>not</i> restricted to a linked-list like in this example, and can be built around other structures like <a>trees</a>.
</p><p>Using free monads intentionally may seem impractical at first, but their formal nature is particularly well-suited for syntactic problems.
A free monad can be used to track syntax and type while leaving semantics for later, and has found use in parsers and <a>interpreters</a> as a result.<div><a>[34]</a></div>
Others have applied them to more dynamic, operational problems too, such as providing <a>iteratees</a> within a language.<div><a>[35]</a></div>
</p>
<div><span>Comonads</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p>Besides generating monads with extra properties, for any given monad, one can also define a <b>comonad</b>.
Conceptually, if monads represent computations built up from underlying values, then comonads can be seen as reductions back down to values.
Monadic code, in a sense, cannot be fully "unpacked"; once a value is wrapped within a monad, it remains quarantined there along with any side-effects (a good thing in purely functional programming).
Sometimes though, a problem is more about consuming contextual data, which comonads can model explicitly.
</p><p>Technically, a comonad is the <a>categorical dual</a> of a monad, which loosely means that it will have the same required components, only with the direction of the type signatures <i>reversed</i>.
Starting from the <span>bind</span>-centric monad definition, a comonad consists of:
</p>
<ul><li>A type constructor <span>W</span> that marks the higher-order type <span>W T</span></li>
<li>The dual of <span>unit</span>, called <b>counit</b> here, extracts the underlying value from the comonad:</li></ul>
<div>counit(wa) : W T → T
</div>
<ul><li>A reversal of <span>bind</span> (also represented with <code>=>></code>) that <b>extend</b>s a chain of reducing functions:</li></ul>
<div>(wa =>> f) : (W U, W U → T) → W T<div><a>[r]</a></div>
</div>
<p><span>extend</span> and <span>counit</span> must also satisfy duals of the monad laws:
</p>
<div>counit ∘ <b>(</b> (wa =>> f) → wb <b>)</b>  ↔  f(wa) → b
wa =>> counit  ↔  wa
wa <b>(</b> (=>> f(wx = wa)) → wb (=>> g(wy = wb)) → wc <b>)</b>  ↔  <b>(</b> wa (=>> f(wx = wa)) → wb <b>)</b> (=>> g(wy = wb)) → wc
</div>
<p>Analogous to monads, comonads can also be derived from functors using a dual of <span>join</span>:
</p>
<ul><li><b>duplicate</b> takes an already comonadic value and wraps it in another layer of comonadic structure:</li></ul>
<div>duplicate(wa) : W T → W (W T)
</div>
<p>While operations like <span>extend</span> are reversed, however, a comonad does <i>not</i> reverse functions it acts on, and consequently, comonads are still functors with <span>map</span>, not <a>cofunctors</a>.
The alternate definition with <span>duplicate</span>, <span>counit</span>, and <span>map</span> must also respect its own comonad laws:
</p>
<div>((map duplicate) ∘ duplicate) wa  ↔  (duplicate ∘ duplicate) wa  ↔  wwwa
((map counit) ∘ duplicate)    wa  ↔  (counit ∘ duplicate)    wa  ↔  wa
((map map φ) ∘ duplicate)     wa  ↔  (duplicate ∘ (map φ))   wa  ↔  wwb
</div>
<p>And as with monads, the two forms can be converted automatically:
</p>
<div>(map φ) wa    ↔  wa =>> (φ ∘ counit) wx
duplicate wa  ↔  wa =>> wx
</div>
<div>wa =>> f(wx)  ↔  ((map f) ∘ duplicate) wa
</div>
<p>A simple example is the <b>Product comonad</b>, which outputs values based on an input value and shared environment data.
In fact, the <code>Product</code> comonad is just the dual of the <code>Writer</code> monad and effectively the same as the <code>Reader</code> monad (both discussed below).
<code>Product</code> and <code>Reader</code> differ only in which function signatures they accept, and how they complement those functions by wrapping or unwrapping values.
</p><p>A less trivial example is the <b>Stream comonad</b>, which can be used to represent <a>data streams</a> and attach filters to the incoming signals with <span>extend</span>.
In fact, while not as popular as monads, researchers have found comonads particularly useful for <a>stream processing</a> and modeling <a>dataflow programming</a>.<div><a>[36]</a></div><div><a>[37]</a></div>
</p><p>Due to their strict definitions, however, one cannot simply move objects back and forth between monads and comonads.
As an even higher abstraction, <a>arrows</a> can subsume both structures, but finding more granular ways to combine monadic and comonadic code is an active area of research.<div><a>[38]</a></div><div><a>[39]</a></div>
</p>
<div><span>See also</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<p><b>Alternatives for modeling computations:</b>
</p>
<ul><li><a>Effect systems</a> (particularly algebraic effect handlers) are a different way to describe side effects as types</li>
<li><a>Uniqueness types</a> are a third approach to handling side-effects in functional languages</li></ul>
<p><b>Related design concepts:</b>
</p>
<ul><li><a>Aspect-oriented programming</a> emphasizes separating out ancillary bookkeeping code to improve modularity and simplicity</li>
<li><a>Inversion of control</a> is the abstract principle of calling specific functions from an overarching framework</li>
<li><a>Type classes</a> are a specific language feature used to implement monads and other structures in Haskell</li>
<li>The <a>decorator pattern</a> is a more concrete, ad-hoc way to achieve similar benefits in object-oriented programming</li></ul>
<p><b>Generalizations of monads:</b>
</p>
<ul><li><a>Applicative functors</a> generalize from monads by keeping only <span>unit</span> and laws relating it to <span>map</span></li>
<li><a>Arrows</a> use additional structure to bring plain functions and monads under a single interface</li>
<li><a>Monad transformers</a> act on distinct monads to combine them modularly</li></ul>
<div><span>Notes</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<style>.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style></br>
</br><div>
<li><span><b><a>^</a></b></span> <span>Due to the fact that functions on multiple <a>free variables</a> are common in programming, monads as described in this article are technically what category theorists would call <a>strong monads</a>.<div><a>[3]</a></div></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span>Specific motivation for Maybe can be found in (Hutton 2016).<div><a>[7]</a></div></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span>Hutton abstracts a <code>bind</code> which when given a type <i>a</i> that may fail, and a mapping <i>a</i>→<i>b</i> that may fail, produces a result <i>b</i> that may fail. (Hutton, 2016)<div><a>[7]</a></div> </span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span>(Hutton 2016) notes that Just might denote Success, and Nothing might denote Failure.<div><a>[7]</a></div></span>
</li>
<li><span><b><a>^</a></b></span> <span>Semantically, <span>M</span> is not trivial and represents an <a>endofunctor</a> over the <a>category</a> of all well-typed values: <span><span><div>
  <div>
    <div>
      <div>
        <div>M</div>
        <div>:</div>
        <div>
          <div>
            <div>V</div>
            <div>a</div>
            <div>l</div>
          </div>
        </div>
        <div>→</div>
        <div>
          <div>
            <div>V</div>
            <div>a</div>
            <div>l</div>
          </div>
        </div>
      </div>
    </div>
    <div>{\displaystyle M:{\mathit {Val}}\to {\mathit {Val}}}</div>
  </div>
</div></span><div></div></span></span>
</li>
<li><span><b><a>^</a></b></span> <span>While a (parametrically polymorphic) function in programming terms, <span>unit</span> (often called <span>η</span> in category theory) is mathematically a <a>natural transformation</a>, which maps between <i>functors</i>: <span><span><div>
  <div>
    <div>
      <div>
        <div>
          <div>η</div>
          <div>
            <div>A</div>
          </div>
        </div>
        <div>:</div>
        <div>
          <div>i</div>
          <div>d</div>
        </div>
        <div>(</div>
        <div>
          <div>
            <div>
              <div>V</div>
              <div>a</div>
              <div>l</div>
            </div>
          </div>
          <div>
            <div>A</div>
          </div>
        </div>
        <div>)</div>
        <div>→</div>
        <div>M</div>
        <div>(</div>
        <div>
          <div>
            <div>
              <div>V</div>
              <div>a</div>
              <div>l</div>
            </div>
          </div>
          <div>
            <div>A</div>
          </div>
        </div>
        <div>)</div>
      </div>
    </div>
    <div>{\displaystyle \eta _{A}:\mathrm {id} ({\mathit {Val}}_{A})\to M({\mathit {Val}}_{A})}</div>
  </div>
</div></span><div></div></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><span>bind</span>, on the other hand, is not a natural transformation in category theory, but rather an extension <span><span><div>
  <div>
    <div>
      <div>
        <div>
          <div>−</div>
          <div>
            <div>∗</div>
          </div>
        </div>
      </div>
    </div>
    <div>{\displaystyle -^{*}}</div>
  </div>
</div></span><div></div></span> that <a>lifts</a> a mapping (from values to computations) into a morphism between computations: <span><span><div>
  <div>
    <div>
      <div>
        <div>∀</div>
        <div>f</div>
        <div>:</div>
        <div>
          <div>
            <div>
              <div>V</div>
              <div>a</div>
              <div>l</div>
            </div>
          </div>
          <div>
            <div>A</div>
          </div>
        </div>
        <div>→</div>
        <div>M</div>
        <div>(</div>
        <div>
          <div>
            <div>
              <div>V</div>
              <div>a</div>
              <div>l</div>
            </div>
          </div>
          <div>
            <div>B</div>
          </div>
        </div>
        <div>)</div>
        <div>,</div>
        <div>
          <div>f</div>
          <div>
            <div>∗</div>
          </div>
        </div>
        <div>:</div>
        <div>M</div>
        <div>(</div>
        <div>
          <div>
            <div>
              <div>V</div>
              <div>a</div>
              <div>l</div>
            </div>
          </div>
          <div>
            <div>A</div>
          </div>
        </div>
        <div>)</div>
        <div>→</div>
        <div>M</div>
        <div>(</div>
        <div>
          <div>
            <div>
              <div>V</div>
              <div>a</div>
              <div>l</div>
            </div>
          </div>
          <div>
            <div>B</div>
          </div>
        </div>
        <div>)</div>
      </div>
    </div>
    <div>{\displaystyle \forall f:{\mathit {Val}}_{A}\to M({\mathit {Val}}_{B}),f^{*}:M({\mathit {Val}}_{A})\to M({\mathit {Val}}_{B})}</div>
  </div>
</div></span><div></div></span></span>
</li>
<li><span><b><a>^</a></b></span> <span>Strictly speaking, <span>bind</span> may not be formally associative in all contexts because it corresponds to application within <a>lambda calculus</a>, not mathematics. In rigorous lambda-calculus, evaluating a <span>bind</span> may require first wrapping the right term (when binding two monadic values) or the bind itself (between two monadic functions) in an <a>anonymous function</a> to still accept input from the left.<div><a>[10]</a></div></span>
</li>
<li><span><b><a>^</a></b></span> <span>By GHC version 7.10.1, and going forward, Haskell began enforcing Haskell's 2014 Applicative Monad proposal (AMP) which requires the insertion of 7 lines of code into any existing modules which use monads.<div><a>[25]</a></div></span>
</li>
<li><span><b><a>^</a></b></span> <span>These natural transformations are usually denoted as morphisms η, μ. That is:  η, μ denote <i>unit</i>, and <i>join</i> respectively.</span>
</li>
<li><span><b><a>^</a></b></span> <span>Some languages like Haskell even provide a pseudonym for <span>map</span> in other contexts called <code>lift</code>, along with multiple versions for different parameter counts, a detail ignored here.</span>
</li>
<li><span><b><a>^</a></b></span> <span>In category theory, the <code>Identity</code> monad can also be viewed as emerging from <a>adjunction</a> of any functor with its inverse.</span>
</li>
<li><span><b><a>^</a></b></span> <span>Category theory views these collection monads as adjunctions between the <a>free functor</a> and different functors from the <a>category of sets</a> to the <a>category of monoids</a>.</span>
</li>
<li><span><b><a>^</a></b></span> <span>Here the task for the programmer is to construct an appropriate monoid, or perhaps to choose a monoid from a library.</span>
</li>
<li><span><b><a>^</a></b></span> <span>The reader may wish to follow McCann's thread<div><a>[6]</a></div> and compare it with the Types below.</span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span>In this case, the <code>bind</code> has <i>pasted</i> in a <code>string</code> where previously only an <code>integer</code> had been; that is, the programmer has constructed an <a>adjunction</a>: a tuple <code>(x,s)</code>, denoted <code>int * string</code> in the pseudocode <a>§ above</a>.</span>
</li>
<li><span><b><a>^</a></b></span> <span>Algebraically, the relationship between the two (non-commutative) monoid aspects resembles that of a <a>near-semiring</a>, and some additive monads do qualify as such. However, not all additive monads meet the <a>distributive</a> laws of even a near-semiring.<div><a>[33]</a></div></span>
</li>
<li><span><b><a>^</a></b></span> <span>In Haskell, <span>extend</span> is actually defined with the inputs swapped, but as currying is not used in this article, it is defined here as the exact dual of <span>bind</span>.</span>
</li>
</div>
<div><span>References</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<div></div></br>
<div>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a> <a><div><i><b>c</b></i></div></a> <a><div><i><b>d</b></i></div></a> <a><div><i><b>e</b></i></div></a> <a><div><i><b>f</b></i></div></a> <a><div><i><b>g</b></i></div></a></span> <span><style>.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}</style><div>O'Sullivan, Bryan; Goerzen, John; Stewart, Don (2009). <a>"Monads"</a>. <a><i>Real World Haskell</i></a>. Sebastopol, California: O'Reilly Media. chapter 14. <a>ISBN</a> <a><div>978-0596514983</div></a>.</div><span></span></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span><div></div><div><a>Wadler, Philip</a> (June 1990). <i>Comprehending Monads</i>. ACM Conference on LISP and Functional Programming. Nice, France. <a>CiteSeerX</a> <span><a>10.1.1.33.5381</a></span>.</div><span></span></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a> <a><div><i><b>c</b></i></div></a></span> <span><div></div><div><a>Moggi, Eugenio</a> (1991). <a>"Notions of computation and monads"</a> <span>(PDF)</span>. <i>Information and Computation</i>. <b>93</b> (1): 55–92. <a>CiteSeerX</a> <span><a>10.1.1.158.5275</a></span>. <a>doi</a>:<a>10.1016/0890-5401(91)90052-4</a>.</div><span></span></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a> <a><div><i><b>c</b></i></div></a> <a><div><i><b>d</b></i></div></a> <a><div><i><b>e</b></i></div></a></span> <span><div></div><div><a>Wadler, Philip</a> (January 1992). <i>The essence of functional programming</i>. 19th Annual ACM Symposium on Principles of Programming Languages. Albuquerque, New Mexico. <a>CiteSeerX</a> <span><a>10.1.1.38.9516</a></span>.</div><span></span></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span><div></div><div><a>Hudak, Paul</a>; Peterson, John; Fasel, Joseph (1999). <a>"About Monads"</a>. <a><i>A Gentle Introduction to Haskell 98</i></a>. chapter 9.</div><span></span></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span><a>C. A. McCann's answer (Jul 23 '10 at 23:39) How and why does the Haskell Cont monad work?</a></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a> <a><div><i><b>c</b></i></div></a></span> <span>Graham Hutton (2016) <i>Programming in Haskell</i> 2nd Edition</span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span><div></div><div>Beckerman, Brian (21 November 2012). <a>"Don't fear the Monad"</a>. <i><a>YouTube</a></i>.</div><span></span><span><code>{{<a>cite web</a>}}</code>:  CS1 maint: url-status (<a>link</a>)</span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Spivey, Mike (1990). <a>"A functional theory of exceptions"</a> <span>(PDF)</span>. <i>Science of Computer Programming</i>. <b>14</b> (1): 25–42. <a>doi</a>:<span><a>10.1016/0167-6423(90)90056-J</a></span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div><a>"Monad laws"</a>. <i>HaskellWiki</i>. haskell.org<span>. Retrieved <span>14 October</span> 2018</span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div><a>"What a Monad is not"</a>. 7 October 2018.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>De Meuter, Wolfgang (1997). <a><i>Monads as a theoretical foundation for AOP</i></a> <span>(PDF)</span>. International Workshop on Aspect Oriented Programming at ECOOP. Jyväskylä, Finland. <a>CiteSeerX</a> <span><a>10.1.1.25.8262</a></span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div><a>"Monad (sans metaphors)"</a>. <i>HaskellWiki</i>. 1 November 2009<span>. Retrieved <span>24 October</span> 2018</span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>O'Sullivan, Bryan; Goerzen, John; Stewart, Don (2009). <a>"Using Parsec"</a>. <a><i>Real World Haskell</i></a>. Sebastopol, California: O'Reilly Media. chapter 16. <a>ISBN</a> <a><div>978-0596514983</div></a>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Stewart, Don (17 May 2007). <a>"Roll Your Own Window Manager: Tracking Focus with a Zipper"</a>. <i>Control.Monad.Writer</i>. <a>Archived</a> from the original on 20 February 2018<span>. Retrieved <span>19 November</span> 2018</span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Benton, Nick (2015). <a>"Categorical Monads and Computer Programming"</a> <span>(PDF)</span>. <i>London Mathematical Society Impact150 Stories</i>. <b>1</b><span>. Retrieved <span>19 November</span> 2018</span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Kiselyov, Olag (2007). "Delimited Continuations in Operating Systems". <i>Modeling and Using Context</i>. Lecture Notes in Computer Science. Springer Berlin Heidelberg. <b>4635</b>. pages 291--302. <a>doi</a>:<a>10.1007/978-3-540-74255-5_22</a>. <a>ISBN</a> <a><div>978-3-540-74255-5</div></a>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div><a>Meijer, Erik</a> (27 March 2012). <a>"Your Mouse is a Database"</a>. <i>ACM Queue</i>. <b>10</b> (3): 20–33. <a>doi</a>:<span><a>10.1145/2168796.2169076</a></span><span>. Retrieved <span>19 November</span> 2018</span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div><a>Iverson, Kenneth</a> (September 1987). <a>"A dictionary of APL"</a>. <i>APL Quote Quad</i>. <b>18</b> (1): 5–40. <a>doi</a>:<a>10.1145/36983.36984</a>. <a>ISSN</a> <a>1088-6826</a>. <a>S2CID</a> <a>18301178</a><span>. Retrieved <span>19 November</span> 2018</span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div><a>Kleisli, Heinrich</a> (1965). <a>"Every standard construction is induced by a pair of adjoint functors"</a> <span>(PDF)</span>. <i>Proceedings of the American Mathematical Society</i>. <b>16</b> (3): 544–546. <a>doi</a>:<span><a>10.1090/S0002-9939-1965-0177024-4</a></span><span>. Retrieved <span>19 November</span> 2018</span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Peter Pepper, ed. (November 1997). <i>The Programming Language Opal</i> (Technical report) (5th corrected ed.). Fachbereich Informatik, Technische Universität Berlin. <a>CiteSeerX</a> <span><a>10.1.1.40.2748</a></span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div><a>Moggi, Eugenio</a> (June 1989). <a><i>Computational lambda-calculus and monads</i></a> <span>(PDF)</span>. Fourth Annual Symposium on Logic in computer science. Pacific Grove, California. <a>CiteSeerX</a> <span><a>10.1.1.26.2787</a></span>.</div><span></span></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span><div></div><div><a>Peyton Jones, Simon L.</a>; <a>Wadler, Philip</a> (January 1993). <a><i>Imperative functional programming</i></a> <span>(PDF)</span>. 20th Annual ACM Symposium on Principles of Programming Languages. Charleston, South Carolina. <a>CiteSeerX</a> <span><a>10.1.1.53.2504</a></span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span> Brent Yorgey <a>Typeclassopedia</a></span>
</li>
<li><span><b><a>^</a></b></span> <span>Stack overflow  <a>(8 Sep 2017) Defining a new monad in haskell raises no instance for Applicative</a></span>
</li>
<li><span><b><a>^</a></b></span> <span> Brent Yorgey <a>Monoids</a></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div><a>"Applicative functor"</a>. <i>HaskellWiki</i>. Haskell.org. 7 May 2018. <a>Archived</a> from the original on 30 October 2018<span>. Retrieved <span>20 November</span> 2018</span>.</div><span></span></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span><div></div><div>Gibbard, Cale (30 December 2011). <a>"Monads as containers"</a>. <i>HaskellWiki</i>. Haskell.org. <a>Archived</a> from the original on 14 December 2017<span>. Retrieved <span>20 November</span> 2018</span>.</div><span></span></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span><div></div><div>Piponi, Dan (7 August 2006). <a>"You Could Have Invented Monads! (And Maybe You Already Have.)"</a>. <i>A Neighborhood of Infinity</i>. <a>Archived</a> from the original on 24 October 2018<span>. Retrieved <span>16 October</span> 2018</span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div><a>"Some Details on F# Computation Expressions"</a><span>. Retrieved <span>9 October</span> 2018</span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div><a>"Do notation considered harmful"</a>. HaskellWiki<span>. Retrieved <span>12 October</span> 2018</span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Giles, Brett (12 August 2013). <a>"Lifting"</a>. <i>HaskellWiki</i>. Haskell.org. <a>Archived</a> from the original on 29 January 2018<span>. Retrieved <span>25 November</span> 2018</span>.</div><span></span></span>
</li>
<li><span>^ <a><div><i><b>a</b></i></div></a> <a><div><i><b>b</b></i></div></a></span> <span><div></div><div>Rivas, Exequiel; Jaskelioff, Mauro; Schrijvers, Tom (July 2015). <a><i>From monoids to near-semirings: the essence of MonadPlus and Alternative</i></a> <span>(PDF)</span>. 17th International ACM Symposium on Principles and Practice of Declarative Programming. Siena, Italy. <a>CiteSeerX</a> <span><a>10.1.1.703.342</a></span>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Swierstra, Wouter (2008). <a>"Data types à la carte"</a> <span>(PDF)</span>. Functional Pearl. <i>Journal of Functional Programming</i>. Cambridge University Press. <b>18</b> (4): 423–436. <a>CiteSeerX</a> <span><a>10.1.1.101.4131</a></span>. <a>doi</a>:<a>10.1017/s0956796808006758</a>. <a>ISSN</a> <a>1469-7653</a>. <a>S2CID</a> <a>21038598</a>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Kiselyov, Oleg (May 2012).  Schrijvers, Tom; Thiemann, Peter (eds.). <a><i>Iteratees</i></a> <span>(PDF)</span>. International Symposium on Functional and Logic Programming. Lecture Notes in Computer Science. Vol. 7294. Kobe, Japan: Springer-Verlag. pp. 166–181. <a>doi</a>:<a>10.1007/978-3-642-29822-6_15</a>. <a>ISBN</a> <a><div>978-3-642-29822-6</div></a>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Uustalu, Tarmo; Vene, Varmo (July 2005).  Horváth, Zoltán (ed.). <a><i>The Essence of Dataflow Programming</i></a> <span>(PDF)</span>. First Summer School, Central European Functional Programming. Lecture Notes in Computer Science. Vol. 4164. Budapest, Hungary: Springer-Verlag. pp. 135–167. <a>CiteSeerX</a> <span><a>10.1.1.62.2047</a></span>. <a>ISBN</a> <a><div>978-3-540-46845-5</div></a>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Uustalu, Tarmo; Vene, Varmo (June 2008). <a>"Comonadic Notions of Computation"</a>. <i>Electronic Notes in Theoretical Computer Science</i>. Elsevier. <b>203</b> (5): 263–284. <a>doi</a>:<span><a>10.1016/j.entcs.2008.05.029</a></span>. <a>ISSN</a> <a>1571-0661</a>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Power, John; Watanabe, Hiroshi (May 2002). <a>"Combining a monad and a comonad"</a> <span>(PDF)</span>. <i>Theoretical Computer Science</i>. Elsevier. <b>280</b> (1–2): 137–162. <a>CiteSeerX</a> <span><a>10.1.1.35.4130</a></span>. <a>doi</a>:<a>10.1016/s0304-3975(01)00024-x</a>. <a>ISSN</a> <a>0304-3975</a>.</div><span></span></span>
</li>
<li><span><b><a>^</a></b></span> <span><div></div><div>Gaboardi, Marco; Katsumata, Shin-ya; Orchard, Dominic; Breuvart, Flavien; Uustalu, Tarmo (September 2016). <a><i>Combining Effects and Coeffects via Grading</i></a> <span>(PDF)</span>. 21st ACM International Conference on Functional Programming. Nara, Japan: Association for Computing Machinery. pp. 476–489. <a>doi</a>:<a>10.1145/2951913.2951939</a>. <a>ISBN</a> <a><div>978-1-4503-4219-3</div></a>.</div><span></span></span>
</li>
</div>
<div><span>External links</span><span><span>[</span><a>edit</a><span>]</span></span></div>
<style>.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style></br>
</br>
</br><div></div>
</br>The Wikibook <i><a>Haskell</a></i> has a page on the topic of: <i><b><a>Understanding monads</a></b></i>

<p><b>HaskellWiki references:</b>
</p>
<ul><li>"<a>All About Monads</a>" (originally by Jeff Newbern) — A comprehensive discussion of all the common monads and how they work in Haskell; includes the "mechanized assembly line" analogy.</li>
<li>"<a>Typeclassopedia</a>" (originally by Brent Yorgey) — A detailed exposition of how the leading typeclasses in Haskell, including monads, interrelate.</li></ul>
<p><b>Tutorials:</b>
</p>
<ul><li>"<a>A Fistful of Monads</a>" (from the online Haskell textbook <i><a>Learn You a Haskell for Great Good!</a></i> — A chapter introducing monads from the starting-point of functor and applicative functor typeclasses, including examples.</li>
<li>"<a>For a Few Monads More</a>" — A second chapter explaining more details and examples, including a <code>Probability</code> monad for <a>Markov chains</a>.</li>
<li>"<a>Functors, Applicatives, And Monads In Pictures</a> (by Aditya Bhargava) — A quick, humorous, and visual tutorial on monads.</li></ul>
<p><b>Interesting cases:</b>
</p>
<ul><li>"<a>UNIX pipes as IO monads</a>" (by Oleg Kiselyov) — A short essay explaining how <a>Unix pipes</a> are effectively monadic.</li>
<li><i><a>Pro Scala: Monadic Design Patterns for the Web</a></i> (by Gregory Meredith) — An unpublished, full-length manuscript on how to improve many facets of web development in <a>Scala</a> with monads.</li></ul>
</br><style>.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}</style></br><div><div><div><style>.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}</style></br><ul><li><a><div>v</div></a></li><li><a><div>t</div></a></li><li><a><div>e</div></a></li></ul></br><a>Software design patterns</a></div></div><div><div><a>Gang of Four<br></br>patterns</a></div><div></br><table><div><div><div><a>Creational</a></div><div></br>
<ul><li><a>Abstract factory</a></li>
<li><a>Builder</a></li>
<li><a>Factory method</a></li>
<li><a>Prototype</a></li>
<li><a>Singleton</a></li></ul>
</div></div><div><div><a>Structural</a></div><div></br>
<ul><li><a>Adapter</a></li>
<li><a>Bridge</a></li>
<li><a>Composite</a></li>
<li><a>Decorator</a></li>
<li><a>Facade</a></li>
<li><a>Flyweight</a></li>
<li><a>Proxy</a></li></ul>
</div></div><div><div><a>Behavioral</a></div><div></br>
<ul><li><a>Chain of responsibility</a></li>
<li><a>Command</a></li>
<li><a>Interpreter</a></li>
<li><a>Iterator</a></li>
<li><a>Mediator</a></li>
<li><a>Memento</a></li>
<li><a>Observer</a></li>
<li><a>State</a></li>
<li><a>Strategy</a></li>
<li><a>Template method</a></li>
<li><a>Visitor</a></li></ul>
</div></div></div></table></br></div></div><div><div><a>Concurrency<br></br>patterns</a></div><div></br>
<ul><li><a>Active object</a></li>
<li><a>Balking</a></li>
<li><a>Binding properties</a></li>
<li><a>Double-checked locking</a></li>
<li><a>Event-based asynchronous</a></li>
<li><a>Guarded suspension</a></li>
<li><a>Join</a></li>
<li><a>Lock</a></li>
<li><a>Monitor</a></li>
<li><a>Proactor</a></li>
<li><a>Reactor</a></li>
<li><a>Read write lock</a></li>
<li><a>Scheduler</a></li>
<li><a>Thread pool</a></li>
<li><a>Thread-local storage</a></li></ul>
</div></div><div><div><a>Architectural<br></br>patterns</a></div><div></br>
<ul><li><a>Front controller</a></li>
<li><a>Interceptor</a></li>
<li><a>MVC</a></li>
<li><a>ADR</a></li>
<li><a>ECS</a></li>
<li><a><i>n</i>-tier</a></li>
<li><a>Specification</a></li>
<li><a>Publish–subscribe</a></li>
<li><a>Naked objects</a></li>
<li><a>Service locator</a></li>
<li><a>Active record</a></li>
<li><a>Identity map</a></li>
<li><a>Data access object</a></li>
<li><a>Data transfer object</a></li>
<li><a>Inversion of control</a></li>
<li><a>Model 2</a></li>
<li><a>Broker</a></li></ul>
</div></div><div><div>Other<br></br>patterns</div><div></br>
<ul><li><a>Blackboard</a></li>
<li><a>Business delegate</a></li>
<li><a>Composite entity</a></li>
<li><a>Dependency injection</a></li>
<li><a>Intercepting filter</a></li>
<li><a>Lazy loading</a></li>
<li><a>Mock object</a></li>
<li><a>Null object</a></li>
<li><a>Object pool</a></li>
<li><a>Servant</a></li>
<li><a>Twin</a></li>
<li><a>Type tunnel</a></li>
<li><a>Method chaining</a></li>
<li><a>Delegation</a></li></ul>
</div></div><div><div>Books</div><div></br>
<ul><li><i><a>Design Patterns</a></i></li>
<li><i><a>Enterprise Integration Patterns</a></i></li></ul>
</div></div><div><div>People</div><div></br>
<ul><li><a>Christopher Alexander</a></li>
<li><a>Erich Gamma</a></li>
<li><a>Ralph Johnson</a></li>
<li><a>John Vlissides</a></li>
<li><a>Grady Booch</a></li>
<li><a>Kent Beck</a></li>
<li><a>Ward Cunningham</a></li>
<li><a>Martin Fowler</a></li>
<li><a>Robert Martin</a></li>
<li><a>Jim Coplien</a></li>
<li><a>Douglas Schmidt</a></li>
<li><a>Linda Rising</a></li></ul>
</div></div><div><div>Communities</div><div></br>
<ul><li><a>The Hillside Group</a></li>
<li><a>The Portland Pattern Repository</a></li></ul>
</div></div><div><div>See also</div><div></br>
<ul><li><a>Anti-pattern</a></li>
<li><a>Architectural pattern</a></li></ul>
</div></div></div></table>
</br><div></div></br><div><div><div><div></div></br><ul><li><a><div>v</div></a></li><li><a><div>t</div></a></li><li><a><div>e</div></a></li></ul></br><a>Formal semantics (natural language)</a></div></div><div><div>Central concepts</div><div></br>
<ul><li><a>Compositionality</a></li>
<li><a>Denotation</a></li>
<li><a>Entailment</a></li>
<li><a>Extension</a></li>
<li><a>Generalized quantifier</a></li>
<li><a>Intension</a></li>
<li><a>Logical form</a></li>
<li><a>Presupposition</a></li>
<li><a>Proposition</a></li>
<li><a>Reference</a></li>
<li><a>Scope</a></li>
<li><a>Speech act</a></li>
<li><a>Syntax–semantics interface</a></li>
<li><a>Truth conditions</a></li></ul>
</div></div><div><div>Topics</div><div></br><table><div><div><div>Areas</div><div></br>
<ul><li><a>Anaphora</a></li>
<li><a>Ambiguity</a></li>
<li><a>Binding</a></li>
<li><a>Conditionals</a></li>
<li><a>Definiteness</a></li>
<li><a>Disjunction</a></li>
<li><a>Evidentiality</a></li>
<li><a>Focus</a></li>
<li><a>Indexicality</a></li>
<li><a>Lexical semantics</a></li>
<li><a>Modality</a></li>
<li><a>Negation</a></li>
<li><a>Propositional attitudes</a></li>
<li><a>Tense–aspect–mood</a></li>
<li><a>Quantification</a></li>
<li><a>Vagueness</a></li></ul>
</div></div><div><div>Phenomena</div><div></br>
<ul><li><a>Antecedent-contained deletion</a></li>
<li><a>Cataphora</a></li>
<li><a>Coercion</a></li>
<li><a>Conservativity</a></li>
<li><a>Counterfactuals</a></li>
<li><a>Cumulativity</a></li>
<li><a>De dicto and de re</a></li>
<li><a>De se</a></li>
<li><a>Deontic modality</a></li>
<li><a>Discourse relations</a></li>
<li><a>Donkey anaphora</a></li>
<li><a>Epistemic modality</a></li>
<li><a>Faultless disagreement</a></li>
<li><a>Free choice inferences</a></li>
<li><a>Givenness</a></li>
<li><a>Crossover effects</a></li>
<li><a>Hurford disjunction</a></li>
<li><a>Inalienable possession</a></li>
<li><a>Intersective modification</a></li>
<li><a>Logophoricity</a></li>
<li><a>Mirativity</a></li>
<li><a>Modal subordination</a></li>
<li><a>Opaque contexts</a></li>
<li><a>Performatives</a></li>
<li><a>Polarity items</a></li>
<li><a>Privative adjectives</a></li>
<li><a>Quantificational variability effect</a></li>
<li><a>Responsive predicate</a></li>
<li><a>Rising declaratives</a></li>
<li><a>Scalar implicature</a></li>
<li><a>Sloppy identity</a></li>
<li><a>Subsective modification</a></li>
<li><a>Subtrigging</a></li>
<li><a>Telicity</a></li>
<li><a>Temperature paradox</a></li>
<li><a>Veridicality</a></li></ul>
</div></div></div></table></br></div></div><div><div>Formalism</div><div></br><div><div><div>Formal systems</div><div></br>
<ul><li><a>Alternative semantics</a></li>
<li><a>Categorial grammar</a></li>
<li><a>Combinatory categorial grammar</a></li>
<li><a>Discourse representation theory</a></li>
<li><a>Dynamic semantics</a></li>
<li><a>Frame semantics</a></li>
<li><a>Generative grammar</a></li>
<li><a>Glue semantics</a></li>
<li><a>Inquisitive semantics</a></li>
<li><a>Intensional logic</a></li>
<li><a>Lambda calculus</a></li>
<li><a>Mereology</a></li>
<li><a>Montague grammar</a></li>
<li><a>Segmented discourse representation theory</a></li>
<li><a>Situation semantics</a></li>
<li><a>Supervaluationism</a></li>
<li><a>Type theory</a></li>
<li><a>TTR</a></li></ul>
</div></div><div><div>Concepts</div><div></br>
<ul><li><a>Autonomy of syntax</a></li>
<li><a>Context set</a></li>
<li><a>Continuation</a></li>
<li><a>Conversational scoreboard</a></li>
<li><a>Existential closure</a></li>
<li><a>Function application</a></li>
<li><a>Meaning postulate</a></li>
<li><a>Monads</a></li>
<li><a>Possible world</a></li>
<li><a>Quantifier raising</a></li>
<li><a>Quantization</a></li>
<li><a>Question under discussion</a></li>
<li><a>Squiggle operator</a></li>
<li><a>Strict conditional</a></li>
<li><a>Type shifter</a></li>
<li><a>Universal grinder</a></li></ul>
</div></div></div></table></br></div></div><div><div>See also</div><div></br>
<ul><li><a>Cognitive semantics</a></li>
<li><a>Computational semantics</a></li>
<li><a>Distributional semantics</a></li>
<li><a>Formal grammar</a></li>
<li><a>Inferentialism</a></li>
<li><a>Linguistics wars</a></li>
<li><a>Term logic</a></li>
<li><a>Philosophy of language</a></li>
<li><a>Pragmatics</a>
<ul><li><a>Context</a></li>
<li><a>Deixis</a></li></ul></li>
<li><a>Semantics of logic</a></li></ul>
</div></div></div></table>




<div><img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" /></div>
</br>Retrieved from "<a>https://en.wikipedia.org/w/index.php?title=Monad_(functional_programming)&oldid=1124938042</a>"
		</br></br><a>Categories</a>: <ul><li><a>1991 in computing</a></li><li><a>Functional programming</a></li><li><a>Software design patterns</a></li><li><a>Programming idioms</a></li></ul></br>Hidden categories: <ul><li><a>CS1 maint: url-status</a></li><li><a>Articles with short description</a></li><li><a>Short description matches Wikidata</a></li><li><a>All articles with unsourced statements</a></li><li><a>Articles with unsourced statements from October 2018</a></li><li><a>Articles with unsourced statements from March 2021</a></li><li><a>Articles with unsourced statements from November 2018</a></li><li><a>Articles with example Haskell code</a></li></ul>
	


</br>
	<div>Navigation menu</div>
	</br>
		

<div>
	<div>
		<span>Personal tools</span>
	</div>
	</br>
		
		<ul><li><span>Not logged in</span></li><li><a><span>Talk</span></a></li><li><a><span>Contributions</span></a></li><li><a><span>Create account</span></a></li><li><a><span>Log in</span></a></li></ul>
		
	
</div>

		</br>
			

<div>
	<div>
		<span>Namespaces</span>
	</div>
	</br>
		
		<ul><li><a><span>Article</span></a></li><li><a><span>Talk</span></a></li></ul>
		
	
</div>

			

<div>
	<input></input>
	<label>
		<span>English</span>
	</label>
	</br>
		
		<ul></ul>
		
	
</div>

		
		</br>
			

<div>
	<div>
		<span>Views</span>
	</div>
	</br>
		
		<ul><li><a><span>Read</span></a></li><li><a><span>Edit</span></a></li><li><a><span>View history</span></a></li></ul>
		
	
</div>

			

<div>
	<input></input>
	<label>
		<span>More</span>
	</label>
	</br>
		
		<ul></ul>
		
	
</div>

			
</br>
	</br>
		<div>
			</br>
				<input></input>
				<input></input>
				<input></input>
				<input></input>
			
		</div>
	


		
	
	

</br>
	</br>
		<a></a>
	
	

<div>
	<div>
		<span>Navigation</span>
	</div>
	</br>
		
		<ul><li><a><span>Main page</span></a></li><li><a><span>Contents</span></a></li><li><a><span>Current events</span></a></li><li><a><span>Random article</span></a></li><li><a><span>About Wikipedia</span></a></li><li><a><span>Contact us</span></a></li><li><a><span>Donate</span></a></li></ul>
		
	
</div>

	

<div>
	<div>
		<span>Contribute</span>
	</div>
	</br>
		
		<ul><li><a><span>Help</span></a></li><li><a><span>Learn to edit</span></a></li><li><a><span>Community portal</span></a></li><li><a><span>Recent changes</span></a></li><li><a><span>Upload file</span></a></li></ul>
		
	
</div>


<div>
	<div>
		<span>Tools</span>
	</div>
	</br>
		
		<ul><li><a><span>What links here</span></a></li><li><a><span>Related changes</span></a></li><li><a><span>Upload file</span></a></li><li><a><span>Special pages</span></a></li><li><a><span>Permanent link</span></a></li><li><a><span>Page information</span></a></li><li><a><span>Cite this page</span></a></li><li><a><span>Wikidata item</span></a></li></ul>
		
	
</div>


<div>
	<div>
		<span>Print/export</span>
	</div>
	</br>
		
		<ul><li><a><span>Download as PDF</span></a></li><li><a><span>Printable version</span></a></li></ul>
		
	
</div>

	

<div>
	<div>
		<span>Languages</span>
	</div>
	</br>
		
		<ul><li><a><span>বাংলা</span></a></li><li><a><span>Català</span></a></li><li><a><span>Čeština</span></a></li><li><a><span>Deutsch</span></a></li><li><a><span>Ελληνικά</span></a></li><li><a><span>Español</span></a></li><li><a><span>Français</span></a></li><li><a><span>Italiano</span></a></li><li><a><span>Magyar</span></a></li><li><a><span>日本語</span></a></li><li><a><span>Polski</span></a></li><li><a><span>Русский</span></a></li><li><a><span>Suomi</span></a></li><li><a><span>Українська</span></a></li><li><a><span>中文</span></a></li></ul>
		</br><span><a>Edit links</a></span>
	
</div>





<div>
	<ul>
	<li> This page was last edited on 1 December 2022, at 09:24<span> (UTC)</span>.</li>
	<li>Text is available under the <a>Creative Commons Attribution-ShareAlike License 3.0</a><a></a>;
additional terms may apply.  By using this site, you agree to the <a>Terms of Use</a> and <a>Privacy Policy</a>. Wikipedia® is a registered trademark of the <a>Wikimedia Foundation, Inc.</a>, a non-profit organization.</li>
</ul>

	<ul>
	<li><a>Privacy policy</a></li>
	<li><a>About Wikipedia</a></li>
	<li><a>Disclaimers</a></li>
	<li><a>Contact Wikipedia</a></li>
	<li><a>Mobile view</a></li>
	<li><a>Developers</a></li>
	<li><a>Statistics</a></li>
	<li><a>Cookie statement</a></li>
</ul>

	<ul>
	<li><a><div></div></a></li>
	<li><a><div></div></a></li>
</ul>

</div>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.978","walltime":"1.158","ppvisitednodes":{"value":7887,"limit":1000000},"postexpandincludesize":{"value":155622,"limit":2097152},"templateargumentsize":{"value":12818,"limit":2097152},"expansiondepth":{"value":16,"limit":100},"expensivefunctioncount":{"value":42,"limit":500},"unstrip-depth":{"value":1,"limit":20},"unstrip-size":{"value":174329,"limit":5000000},"entityaccesscount":{"value":0,"limit":400},"timingprofile":["100.00%  893.253      1 -total"," 41.53%  370.982      2 Template:Reflist"," 13.67%  122.070      3 Template:Cite_book"," 11.05%   98.697      5 Template:Citation_needed"," 10.19%   91.022      6 Template:Fix","  8.31%   74.232     10 Template:Cite_journal","  8.16%   72.906      8 Template:Rp","  7.65%   68.336      8 Template:R/superscript","  7.32%   65.373      5 Template:Navbox","  7.01%   62.613      1 Template:Short_description"]},"scribunto":{"limitreport-timeusage":{"value":"0.474","limit":"10.000"},"limitreport-memusage":{"value":7704450,"limit":52428800}},"cachereport":{"origin":"mw1351","timestamp":"20221203124255","ttl":1814400,"transientcontent":false}}});});</script>
<script>{"@context":"https:\/\/schema.org","@type":"Article","name":"Monad (functional programming)","url":"https:\/\/en.wikipedia.org\/wiki\/Monad_(functional_programming)","sameAs":"http:\/\/www.wikidata.org\/entity\/Q1579914","mainEntity":"http:\/\/www.wikidata.org\/entity\/Q1579914","author":{"@type":"Organization","name":"Contributors to Wikimedia projects"},"publisher":{"@type":"Organization","name":"Wikimedia Foundation, Inc.","logo":{"@type":"ImageObject","url":"https:\/\/www.wikimedia.org\/static\/images\/wmf-hor-googpub.png"}},"datePublished":"2004-04-06T03:10:26Z","dateModified":"2022-12-01T09:24:53Z","headline":"design pattern in functional programming to build generic types"}</script><script>{"@context":"https:\/\/schema.org","@type":"Article","name":"Monad (functional programming)","url":"https:\/\/en.wikipedia.org\/wiki\/Monad_(functional_programming)","sameAs":"http:\/\/www.wikidata.org\/entity\/Q1579914","mainEntity":"http:\/\/www.wikidata.org\/entity\/Q1579914","author":{"@type":"Organization","name":"Contributors to Wikimedia projects"},"publisher":{"@type":"Organization","name":"Wikimedia Foundation, Inc.","logo":{"@type":"ImageObject","url":"https:\/\/www.wikimedia.org\/static\/images\/wmf-hor-googpub.png"}},"datePublished":"2004-04-06T03:10:26Z","dateModified":"2022-12-01T09:24:53Z","headline":"design pattern in functional programming to build generic types"}</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":95,"wgHostname":"mw1413"});});</script>

</body></html>